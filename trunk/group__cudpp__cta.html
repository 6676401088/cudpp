<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP CTA-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">2.0</span></div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">CUDPP CTA-Level API</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_traits.html">ScanTraits&lt; T, Oper, backward, exclusive, multiRow, sums, fullBlock &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class containing compile-time parameters to the scan functions.  <a href="class_scan_traits.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_segmented_scan_traits.html">SegmentedScanTraits&lt; T, Oper, backward, exclusivity, doShiftFlags, fullBlock, sums, sm12OrBetter &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class containing compile-time parameters to the segmented scan functions.  <a href="class_segmented_scan_traits.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Compress Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gafcc34d809746dbd24ee0c5715a8a955a"></a><!-- doxytag: member="cudpp_cta::binSearch_frag_mult" ref="gafcc34d809746dbd24ee0c5715a8a955a" args="(T *keyArraySmem, T *valueArraySmem, int offset, int &amp;mid, T cmpValue, T testValue, int myAddress, int testGlobalIndex, T *globalPointerArray, T *globalStringArray, int bIndex, size_t numElements)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binSearch_frag_mult</b> (T *keyArraySmem, T *valueArraySmem, int offset, int &amp;mid, T cmpValue, T testValue, int myAddress, int testGlobalIndex, T *globalPointerArray, T *globalStringArray, int bIndex, size_t numElements)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf6c9d58ce162396ebe159296b1557406"></a><!-- doxytag: member="cudpp_cta::linearStringMerge" ref="gaf6c9d58ce162396ebe159296b1557406" args="(T *searchArray, T *pointerArray, T *A_values, T myKey, T myAddress, int &amp;index, T &amp;cmpValue, T *saveGlobalArray, T *savePointerArray, T *stringValues, int myStartIdxC, int myStartIdxA, int myStartIdxB, int localAPartSize, int localBPartSize, int localCPartSize, T localMaxB, T finalMaxB, T localMinB, int tid, int aIndex, int bIndex, int offset, int subPartitions, size_t numElements)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearStringMerge</b> (T *searchArray, T *pointerArray, T *A_values, T myKey, T myAddress, int &amp;index, T &amp;cmpValue, T *saveGlobalArray, T *savePointerArray, T *stringValues, int myStartIdxC, int myStartIdxA, int myStartIdxB, int localAPartSize, int localBPartSize, int localCPartSize, T localMaxB, T finalMaxB, T localMinB, int tid, int aIndex, int bIndex, int offset, int subPartitions, size_t numElements)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae63e681e7320814ce80cc761e88bce89"></a><!-- doxytag: member="cudpp_cta::binSearch_fragment" ref="gae63e681e7320814ce80cc761e88bce89" args="(T *binArray, T *pointerBinArray, int offset, int &amp;mid, T cmpValue, T testValue, T myAddress, T *globalStringArray, T *globalStringArray2, size_t numElements)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binSearch_fragment</b> (T *binArray, T *pointerBinArray, int offset, int &amp;mid, T cmpValue, T testValue, T myAddress, T *globalStringArray, T *globalStringArray2, size_t numElements)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga39888ffdb93ea78735d71751ab4a7cf9"></a><!-- doxytag: member="cudpp_cta::lin_merge_simple" ref="ga39888ffdb93ea78735d71751ab4a7cf9" args="(T &amp;cmpValue, T myKey, T myAddress, int &amp;index, T *BKeys, T *BValues, T *stringValues, T *A_values, T *A_keys_out, T *A_values_out, int myStartIdxA, int myStartIdxB, int myStartIdxC, T localMinB, T localMaxB, int aCont, int bCont, int totalSize, int sizePerPartition, int i, T *stringValues2, size_t numElements)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lin_merge_simple</b> (T &amp;cmpValue, T myKey, T myAddress, int &amp;index, T *BKeys, T *BValues, T *stringValues, T *A_values, T *A_keys_out, T *A_values_out, int myStartIdxA, int myStartIdxB, int myStartIdxC, T localMinB, T localMaxB, int aCont, int bCont, int totalSize, int sizePerPartition, int i, T *stringValues2, size_t numElements)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad9900ee2df20e7aa9e6f269cef665e05"></a><!-- doxytag: member="cudpp_cta::bin_search_block" ref="gad9900ee2df20e7aa9e6f269cef665e05" args="(T &amp;cmpValue, T tmpVal, T *in, T *addressPad, const T *stringVals, int &amp;j, int bump, T *stringVals2, size_t numElements)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bin_search_block</b> (T &amp;cmpValue, T tmpVal, T *in, T *addressPad, const T *stringVals, int &amp;j, int bump, T *stringVals2, size_t numElements)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabfe5194e5b8d71cae51aa83b5fdce0c2"></a><!-- doxytag: member="cudpp_cta::lin_search_block" ref="gabfe5194e5b8d71cae51aa83b5fdce0c2" args="(T &amp;cmpValue, T &amp;tmpVal, T *in, T *addressPad, const T *stringVals, int &amp;j, int offset, int last, int startAddress, int addPart, T *stringVals2, size_t numElements)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lin_search_block</b> (T &amp;cmpValue, T &amp;tmpVal, T *in, T *addressPad, const T *stringVals, int &amp;j, int offset, int last, int startAddress, int addPart, T *stringVals2, size_t numElements)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga977819d5f7c70b88789dbcf184b662cd"></a><!-- doxytag: member="cudpp_cta::compareSwapVal" ref="ga977819d5f7c70b88789dbcf184b662cd" args="(T &amp;A1, T &amp;A2, const int index1, const int index2, T *scratch, const T *stringVals, T *stringVals2, size_t numElements)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compareSwapVal</b> (T &amp;A1, T &amp;A2, const int index1, const int index2, T *scratch, const T *stringVals, T *stringVals2, size_t numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8930dc88a7ef98e2b2644362a26b342f"></a><!-- doxytag: member="cudpp_cta::BitArraySetBit" ref="ga8930dc88a7ef98e2b2644362a26b342f" args="(huffman_code *ba, unsigned int bit)" -->
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>BitArraySetBit</b> (huffman_code *ba, unsigned int bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78ddc2a8ddbdb6a1c1d96a8d7873e2d8"></a><!-- doxytag: member="cudpp_cta::BitArrayShiftLeft" ref="ga78ddc2a8ddbdb6a1c1d96a8d7873e2d8" args="(huffman_code *ba, unsigned int shifts)" -->
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>BitArrayShiftLeft</b> (huffman_code *ba, unsigned int shifts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3fa64310fff21871b3fc0bc591d5db0d"></a><!-- doxytag: member="cudpp_cta::BitArrayShiftRight" ref="ga3fa64310fff21871b3fc0bc591d5db0d" args="(huffman_code *ba, unsigned int shifts)" -->
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>BitArrayShiftRight</b> (huffman_code *ba, unsigned int shifts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf2d158a8832bd6f7d10bdb825aa53742"></a><!-- doxytag: member="cudpp_cta::FindMinimumCount" ref="gaf2d158a8832bd6f7d10bdb825aa53742" args="(my_huffman_node_t *ht, int elements)" -->
__device__ int&#160;</td><td class="memItemRight" valign="bottom"><b>FindMinimumCount</b> (my_huffman_node_t *ht, int elements)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Merge Sort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_cta::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gaef46c9603f302b6cddb0721ef2188071">bin_search_block</a> (T &amp;cmpValue, T tmpVal, T *in, unsigned int &amp;j, unsigned int bump, unsigned int addPart)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search within a single block (blockSort)  <a href="#gaef46c9603f302b6cddb0721ef2188071"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gaff88a7f681f553cc0f94002adf5cdebc">lin_search_block</a> (T &amp;cmpValue, T mVal, unsigned int &amp;tmpVal, T *in, unsigned int *addressPad, unsigned int &amp;j, unsigned int offset, unsigned int last, unsigned int startAddress, unsigned int addPart)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear search within a single block (blockSort)  <a href="#gaff88a7f681f553cc0f94002adf5cdebc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga86edc089459ae4161acd99f39e86aa7b">compareSwapVal</a> (T &amp;A1, T &amp;A2, unsigned int &amp;ref1, unsigned int &amp;ref2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For blockSort. Compares two values and decides to swap if A1 &gt; A2.  <a href="#ga86edc089459ae4161acd99f39e86aa7b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga54a937b1d2c5300c07a7a5f8e21c1b9c"></a><!-- doxytag: member="cudpp_cta::binSearch_fragment_lower" ref="ga54a937b1d2c5300c07a7a5f8e21c1b9c" args="(T *binArray, int offset, int &amp;mid, T testValue)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binSearch_fragment_lower</b> (T *binArray, int offset, int &amp;mid, T testValue)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad91cf75c758409004ce5b18f3026dc95"></a><!-- doxytag: member="cudpp_cta::binSearch_fragment_higher" ref="gad91cf75c758409004ce5b18f3026dc95" args="(T *binArray, int offset, int &amp;mid, T testValue)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binSearch_fragment_higher</b> (T *binArray, int offset, int &amp;mid, T testValue)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0d9db7555b80a47f5a2be93d97a84b6c"></a><!-- doxytag: member="cudpp_cta::binSearch_whole_lower" ref="ga0d9db7555b80a47f5a2be93d97a84b6c" args="(T *BKeys, int &amp;index, T myKey)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binSearch_whole_lower</b> (T *BKeys, int &amp;index, T myKey)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga98ee643c3d847d6892ab0958308c3622"></a><!-- doxytag: member="cudpp_cta::binSearch_whole_higher" ref="ga98ee643c3d847d6892ab0958308c3622" args="(T *BKeys, int &amp;index, T myKey)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binSearch_whole_higher</b> (T *BKeys, int &amp;index, T myKey)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gac422d7926d1644cb4c309b3c57ca9763">linearMerge_lower</a> (T *searchArray, T myKey, unsigned int myVal, int &amp;index, T *saveGlobalArray, unsigned int *saveValueArray, int myStartIdxC, T nextMaxB, int localAPartSize, int localBPartSize, T localMaxB, T localMinB, int aIndex, int bIndex, int offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear search in our shared memory (done after binary search). It merges the partition on the left side with the associated partition on the right side.  <a href="#gac422d7926d1644cb4c309b3c57ca9763"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga89e615395989d354aa30c5875543e762">linearMerge_higher</a> (T *searchArray, T myKey, unsigned int myVal, int &amp;index, T *saveGlobalArray, unsigned int *saveValueArray, int myStartIdxC, T localMinB, T nextMaxB, int aIndex, int bIndex, int offset, int localAPartSize, int localBPartSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear search in our shared memory (done after binary search). It merges the partition on the right side with the associated partition on the left side.  <a href="#ga89e615395989d354aa30c5875543e762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67cf5220afab3f55dde96a0ee40ace3e"></a><!-- doxytag: member="cudpp_cta::BLOCKSORT_SIZE" ref="ga67cf5220afab3f55dde96a0ee40ace3e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKSORT_SIZE</b>&#160;&#160;&#160;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a4a49648352df52019a645a6c79c3ef"></a><!-- doxytag: member="cudpp_cta::CTA_BLOCK" ref="ga0a4a49648352df52019a645a6c79c3ef" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTA_BLOCK</b>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad51dc324f1c7e27cc95bc1e13b33256"></a><!-- doxytag: member="cudpp_cta::DEPTH_simple" ref="gaad51dc324f1c7e27cc95bc1e13b33256" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH_simple</b>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga182f51926c5aed7bab42c5bb734a9d78"></a><!-- doxytag: member="cudpp_cta::DEPTH_multi" ref="ga182f51926c5aed7bab42c5bb734a9d78" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH_multi</b>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9fde26757c83712a3b8f00bf63b37f40"></a><!-- doxytag: member="cudpp_cta::CTASIZE_simple" ref="ga9fde26757c83712a3b8f00bf63b37f40" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTASIZE_simple</b>&#160;&#160;&#160;256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e8423b5c0f2b86994c46323ab338a4f"></a><!-- doxytag: member="cudpp_cta::CTASIZE_multi" ref="ga6e8423b5c0f2b86994c46323ab338a4f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTASIZE_multi</b>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd2f8bd5d190a5546118d64ae79da2ff"></a><!-- doxytag: member="cudpp_cta::INTERSECT_A_BLOCK_SIZE_simple" ref="gafd2f8bd5d190a5546118d64ae79da2ff" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_A_BLOCK_SIZE_simple</b>&#160;&#160;&#160;DEPTH_simple*CTASIZE_simple</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2da8dbaa754a1d61ac374fb9434db8fe"></a><!-- doxytag: member="cudpp_cta::INTERSECT_B_BLOCK_SIZE_simple" ref="ga2da8dbaa754a1d61ac374fb9434db8fe" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_B_BLOCK_SIZE_simple</b>&#160;&#160;&#160;2*DEPTH_simple*CTASIZE_simple</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd0407f53e304fbada8a98506ed2bb98"></a><!-- doxytag: member="cudpp_cta::INTERSECT_A_BLOCK_SIZE_multi" ref="gafd0407f53e304fbada8a98506ed2bb98" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_A_BLOCK_SIZE_multi</b>&#160;&#160;&#160;DEPTH_multi*CTASIZE_multi</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e8706489af5960a9bda529fb1afd6ff"></a><!-- doxytag: member="cudpp_cta::INTERSECT_B_BLOCK_SIZE_multi" ref="ga8e8706489af5960a9bda529fb1afd6ff" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_B_BLOCK_SIZE_multi</b>&#160;&#160;&#160;2*DEPTH_multi*CTASIZE_multi</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Radix Sort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_cta::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool doFlip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga05ad3c672e73b35a200893881f3d1cd2">floatFlip</a> (uint f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips bits of single-precision floating-point number (parameterized by doFlip)  <a href="#ga05ad3c672e73b35a200893881f3d1cd2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool doFlip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga3cf28e5904a54e10af2d1c3fea729a59">floatUnflip</a> (uint f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses bit-flip of single-precision floating-point number (parameterized by doFlip)  <a href="#ga3cf28e5904a54e10af2d1c3fea729a59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int maxlevel&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga5328c4100b48f78b8ae2b11126ae241b">scanwarp</a> (T val, volatile T *sData)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans one warp quickly, optimized for 32-element warps, using shared memory.  <a href="#ga5328c4100b48f78b8ae2b11126ae241b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gabfa515588187af6524cbfd4d76fd16c5">scan4</a> (uint4 idata)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans 4*CTA_SIZE unsigned ints in a block.  <a href="#gabfa515588187af6524cbfd4d76fd16c5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int ctasize&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ uint4&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gac598a1e6647cdfdb14ab24d0411ad1f5">rank4</a> (uint4 preds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes output position for each thread given predicate; trues come first then falses.  <a href="#gac598a1e6647cdfdb14ab24d0411ad1f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gad6197a166da7197ec317c4373a8ff232">radixSortBlock</a> (uint4 &amp;key, uint4 &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts one block.  <a href="#gad6197a166da7197ec317c4373a8ff232"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga8927705927517481e2115784a2bf1876">radixSortBlockKeysOnly</a> (uint4 &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts one block. Key-only version.  <a href="#ga8927705927517481e2115784a2bf1876"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Rand Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef">swizzleShift</a> (uint4 *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.  <a href="#ga13c90ad7137a333b8ad2d3ccbb447fef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga6139c8e2423bd271815ffb6feb572080">leftRotate</a> (unsigned int x, unsigned int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the bits in <em>x</em> over by <em>n</em> bits.  <a href="#ga6139c8e2423bd271815ffb6feb572080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gaf6d7ad89002d2bc4ea5dfda74c5044c0">F</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The F scrambling function.  <a href="#gaf6d7ad89002d2bc4ea5dfda74c5044c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga903661679dd9f375fc6cfbcb285f39b1">G</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The G scrambling function.  <a href="#ga903661679dd9f375fc6cfbcb285f39b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga573bcce88a259368f3c2025371bdf656">H</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The H scrambling function.  <a href="#ga573bcce88a259368f3c2025371bdf656"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gaf2de48c1f68ee34f9943390241961fb2">I</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The I scrambling function.  <a href="#gaf2de48c1f68ee34f9943390241961fb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga441b30dd5f34b0f92a826e2835a2924b">FF</a> (uint4 *td, int i, uint4 *Fr, float p, unsigned int *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The FF scrambling function.  <a href="#ga441b30dd5f34b0f92a826e2835a2924b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga45ddf2b6f6e2a98ce150f592ba32d3fa">GG</a> (uint4 *td, int i, uint4 *Gr, float p, unsigned int *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The GG scrambling function.  <a href="#ga45ddf2b6f6e2a98ce150f592ba32d3fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gafa4aefc8ed889545483f0686a5da016f">HH</a> (uint4 *td, int i, uint4 *Hr, float p, unsigned int *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The HH scrambling function.  <a href="#gafa4aefc8ed889545483f0686a5da016f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga19d04cb1fa018499b6f5ef3a873bdd50">II</a> (uint4 *td, int i, uint4 *Ir, float p, unsigned int *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The II scrambling function.  <a href="#ga19d04cb1fa018499b6f5ef3a873bdd50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429">setupInput</a> (unsigned int *input, unsigned int seed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the <em>input</em> array using information of <em>seed</em>, and <em>threadIdx</em>.  <a href="#gad815ed3373fd7ed8be004190d392a429"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051">loadSharedChunkFromMem4</a> (T *s_out, T threadScan[2][4], const T *d_in, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles loading input s_data from global memory to shared memory (vec4 version)  <a href="#gabccbcb560a7006c22db2aada19d37051"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga77ee3d4998aa155a93b1c0af5814d5ba">storeSharedChunkToMem4</a> (T *d_out, T threadScan[2][4], T *s_in, int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles storing result s_data from shared memory to global memory (vec4 version)  <a href="#ga77ee3d4998aa155a93b1c0af5814d5ba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga19caab62e5c027ea3fff08cb15d0efbf">loadSharedChunkFromMem2</a> (T *s_out, T threadScan[2][2], const T *d_in, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles loading input s_data from global memory to shared memory (vec4 version)  <a href="#ga19caab62e5c027ea3fff08cb15d0efbf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gae2d034aecf8335b4878982afff2a8224">storeSharedChunkToMem2</a> (T *d_out, T threadScan[2][2], T *s_in, int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles storing result s_data from shared memory to global memory (vec4 version)  <a href="#gae2d034aecf8335b4878982afff2a8224"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits , int maxlevel&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga2e02e951efac2a6fba038cd102ef0415">warpscan</a> (T val, volatile T *s_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan all warps of a CTA without synchronization.  <a href="#ga2e02e951efac2a6fba038cd102ef0415"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga163e1d81b5e290f00dcdf77060bc5c40">scanWarps</a> (T x, T y, T *s_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a full CTA scan using the warp-scan algorithm.  <a href="#ga163e1d81b5e290f00dcdf77060bc5c40"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gac39bd4553f352fb03361a56b17be04ee">scanCTA</a> (T *s_data, T *d_blockSums, unsigned int blockSumIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CTA-level scan routine; scans s_data in shared memory in each thread block.  <a href="#gac39bd4553f352fb03361a56b17be04ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gab75dfd738e3beffebf497fbf120019fb">DISALLOW_LOADSTORE_OVERLAP</a>&#160;&#160;&#160;1</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Segmented scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63">loadForSegmentedScanSharedChunkFromMem4</a> (T *s_odata, T threadScan0[4], T threadScan1[4], unsigned int &amp;threadFlag, unsigned int *s_oflags, unsigned int *s_oindices, const T *d_idata, const unsigned int *d_iflags, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles loading input s_data from global memory to shared memory (vec4 version)  <a href="#gaf417327731b668f89a1a8a32ae715e63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gab970a2f1d36591efe8376d8a1eaf2964">storeForSegmentedScanSharedChunkToMem4</a> (T *d_odata, T threadScan0[4], T threadScan1[4], unsigned int threadFlag, T *s_idata, unsigned int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles storing result s_data from shared memory to global memory (vec4 version)  <a href="#gab970a2f1d36591efe8376d8a1eaf2964"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8b51979d7cac3f974b17293ded017b04"></a><!-- doxytag: member="cudpp_cta::reduceCTA" ref="ga8b51979d7cac3f974b17293ded017b04" args="(volatile T *s_data)" -->
template&lt;class T , class traits , unsigned int blockSize&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduceCTA</b> (volatile T *s_data)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3ccb3bffa36df08aebb3f2aa31c8e51d"></a><!-- doxytag: member="cudpp_cta::warpSegScan" ref="ga3ccb3bffa36df08aebb3f2aa31c8e51d" args="(T val, unsigned int flag, volatile T *s_data, volatile unsigned int *s_flags, T &amp;oVal, unsigned int &amp;oFlag, bool print=false)" -->
template&lt;class T , class traits , bool isExclusive, unsigned int log_simd_threads&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>warpSegScan</b> (T val, unsigned int flag, volatile T *s_data, volatile unsigned int *s_flags, T &amp;oVal, unsigned int &amp;oFlag, bool print=false)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2b9ad8992708c3ff0bb5d6479603b045"></a><!-- doxytag: member="cudpp_cta::segmentedScanWarps" ref="ga2b9ad8992708c3ff0bb5d6479603b045" args="(T val1, unsigned int flag1, T val2, unsigned int flag2, T *s_data, unsigned int *s_flags)" -->
template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>segmentedScanWarps</b> (T val1, unsigned int flag1, T val2, unsigned int flag2, T *s_data, unsigned int *s_flags)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga1e22f2750f80d47cab975543f6afed40">segmentedScanCTA</a> (T *s_data, unsigned int *s_flags, unsigned int *s_indices, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CTA-level segmented scan routine;.  <a href="#ga1e22f2750f80d47cab975543f6afed40"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Merge Sort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_cta::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__device__ int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gad87bcb57897cfbc6a5d46b9e9a38347c">tie_break_simp</a> (unsigned int myLoc, unsigned int cmpLoc, unsigned int myBound, unsigned int cmpBound, unsigned int myAdd, unsigned int cmpAdd, unsigned int *stringLoc, unsigned int stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks ties in keys (first four characters) returns true if cmpVal &gt; myVal false otherwise.  <a href="#gad87bcb57897cfbc6a5d46b9e9a38347c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga2d5a6f0061060d315186eec3055086f7">bin_search_block_string</a> (T &amp;cmpValue, T tmpVal, T *in, T *addressPad, T *stringVals, int &amp;j, int bump, int sizeRemain, unsigned int stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search within a single block (blockSort)  <a href="#ga2d5a6f0061060d315186eec3055086f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gaed1b743ff0e294651bfc2372d94ce43d">lin_search_block_string</a> (T &amp;cmpValue, T &amp;tmpVal, T *in, T *addressPad, T *stringVals, int &amp;j, int offset, int last, int startAddress, int stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear search within a single block (blockSort)  <a href="#gaed1b743ff0e294651bfc2372d94ce43d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga97b5616a860f477c61b8f97608cd2f4a">compareSwapVal</a> (T &amp;A1, T &amp;A2, const int index1, const int index2, T *scratch, T *stringVals, unsigned int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For blockSort. Compares two values and decides to swap if A1 &gt; A2.  <a href="#ga97b5616a860f477c61b8f97608cd2f4a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga2ecd3f50362c357eb88c37fdf5be8a4c">binSearch_fragment</a> (T *keys, T *address, int offset, int &amp;mid, T cmpValue, T testValue, T myAddress, int myLoc, int cmpLoc, int myBound, int cmpBound, T *globalStringArray, int stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search in our shared memory, with tie breaks for strings.  <a href="#ga2ecd3f50362c357eb88c37fdf5be8a4c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8d7452803458e41a6a454554bb1f84f4"></a><!-- doxytag: member="cudpp_cta::binSearch_frag_mult" ref="ga8d7452803458e41a6a454554bb1f84f4" args="(T *keyArraySmem, T *valueArraySmem, int offset, int &amp;mid, T cmpValue, T testValue, int myAddress, T *globalStringArray, int myStartIdxA, int myStartIdxB, int aIndex, int bIndex, int size, int stringSize)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>binSearch_frag_mult</b> (T *keyArraySmem, T *valueArraySmem, int offset, int &amp;mid, T cmpValue, T testValue, int myAddress, T *globalStringArray, int myStartIdxA, int myStartIdxB, int aIndex, int bIndex, int size, int stringSize)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#ga624550c4d768492aab1eab134d4de0eb">lin_merge_simple</a> (T &amp;cmpValue, T myKey, T myAddress, int &amp;index, T *BKeys, T *BValues, T *stringValues, T *A_keys, T *A_values, T *A_keys_out, T *A_values_out, int myStartIdxA, int myStartIdxB, int myStartIdxC, T localMinB, T localMaxB, int aCont, int bCont, int totalSize, int mySizeA, int mySizeB, unsigned int stringSize, int i, int stepNum, bool &amp;placed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear search in our shared memory (done after binary search), with tie breaks for strings.  <a href="#ga624550c4d768492aab1eab134d4de0eb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gabfe9d7cf34849c957e06edf58787bfe2"></a><!-- doxytag: member="cudpp_cta::linearStringMerge" ref="gabfe9d7cf34849c957e06edf58787bfe2" args="(T *BKeys, T *BValues, T myKey, T myAddress, bool &amp;placed, int &amp;index, T &amp;cmpValue, T *A_keys, T *A_values, T *A_keys_out, T *A_values_out, T *stringValues, int myStartIdxC, int myStartIdxA, int myStartIdxB, int localAPartSize, int localBPartSize, int localCPartSize, T localMaxB, T localMinB, int tid, int aIndex, int bIndex, int i, int stringSize, int totalSize)" -->
template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linearStringMerge</b> (T *BKeys, T *BValues, T myKey, T myAddress, bool &amp;placed, int &amp;index, T &amp;cmpValue, T *A_keys, T *A_values, T *A_keys_out, T *A_values_out, T *stringValues, int myStartIdxC, int myStartIdxA, int myStartIdxB, int localAPartSize, int localBPartSize, int localCPartSize, T localMaxB, T localMinB, int tid, int aIndex, int bIndex, int i, int stringSize, int totalSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67cf5220afab3f55dde96a0ee40ace3e"></a><!-- doxytag: member="cudpp_cta::BLOCKSORT_SIZE" ref="ga67cf5220afab3f55dde96a0ee40ace3e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKSORT_SIZE</b>&#160;&#160;&#160;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a4a49648352df52019a645a6c79c3ef"></a><!-- doxytag: member="cudpp_cta::CTA_BLOCK" ref="ga0a4a49648352df52019a645a6c79c3ef" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTA_BLOCK</b>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad51dc324f1c7e27cc95bc1e13b33256"></a><!-- doxytag: member="cudpp_cta::DEPTH_simple" ref="gaad51dc324f1c7e27cc95bc1e13b33256" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH_simple</b>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga182f51926c5aed7bab42c5bb734a9d78"></a><!-- doxytag: member="cudpp_cta::DEPTH_multi" ref="ga182f51926c5aed7bab42c5bb734a9d78" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH_multi</b>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9fde26757c83712a3b8f00bf63b37f40"></a><!-- doxytag: member="cudpp_cta::CTASIZE_simple" ref="ga9fde26757c83712a3b8f00bf63b37f40" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTASIZE_simple</b>&#160;&#160;&#160;256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e8423b5c0f2b86994c46323ab338a4f"></a><!-- doxytag: member="cudpp_cta::CTASIZE_multi" ref="ga6e8423b5c0f2b86994c46323ab338a4f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTASIZE_multi</b>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd2f8bd5d190a5546118d64ae79da2ff"></a><!-- doxytag: member="cudpp_cta::INTERSECT_A_BLOCK_SIZE_simple" ref="gafd2f8bd5d190a5546118d64ae79da2ff" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_A_BLOCK_SIZE_simple</b>&#160;&#160;&#160;DEPTH_simple*CTASIZE_simple</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2da8dbaa754a1d61ac374fb9434db8fe"></a><!-- doxytag: member="cudpp_cta::INTERSECT_B_BLOCK_SIZE_simple" ref="ga2da8dbaa754a1d61ac374fb9434db8fe" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_B_BLOCK_SIZE_simple</b>&#160;&#160;&#160;2*DEPTH_simple*CTASIZE_simple</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd0407f53e304fbada8a98506ed2bb98"></a><!-- doxytag: member="cudpp_cta::INTERSECT_A_BLOCK_SIZE_multi" ref="gafd0407f53e304fbada8a98506ed2bb98" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_A_BLOCK_SIZE_multi</b>&#160;&#160;&#160;DEPTH_multi*CTASIZE_multi</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e8706489af5960a9bda529fb1afd6ff"></a><!-- doxytag: member="cudpp_cta::INTERSECT_B_BLOCK_SIZE_multi" ref="ga8e8706489af5960a9bda529fb1afd6ff" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INTERSECT_B_BLOCK_SIZE_multi</b>&#160;&#160;&#160;2*DEPTH_multi*CTASIZE_multi</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The CUDPP CTA-Level API contains functions that run on the GPU device. These are CUDA <code>__device__</code> functions that are called from within other CUDA device functions (typically <a class="el" href="group__cudpp__kernel.html">CUDPP Kernel-Level API</a> functions). They are called CTA-level functions because they typically process s_data "owned" by each CTA within shared memory, and are agnostic of any other CTAs that may be running (or how many CTAs are running), other than to compute appropriate global memory addresses. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gab75dfd738e3beffebf497fbf120019fb"></a><!-- doxytag: member="scan_cta.cuh::DISALLOW_LOADSTORE_OVERLAP" ref="gab75dfd738e3beffebf497fbf120019fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISALLOW_LOADSTORE_OVERLAP&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is used to insert syncthreads to avoid perf loss caused by 128-bit load overlap that happens on G80. This gives about a 15% boost on scans on G80. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Parameterize this in case this perf detail changes on future GPUs. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaef46c9603f302b6cddb0721ef2188071"></a><!-- doxytag: member="mergesort_cta.cuh::bin_search_block" ref="gaef46c9603f302b6cddb0721ef2188071" args="(T &amp;cmpValue, T tmpVal, T *in, unsigned int &amp;j, unsigned int bump, unsigned int addPart)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void bin_search_block </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cmpValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tmpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bump</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addPart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binary search within a single block (blockSort) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cmpValue</td><td>Value being considered from other partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmpVal</td><td>My Value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>The index we are considering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bump</td><td>The offset we update by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addPart</td><td>Tie break (left partition vs right partition) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaff88a7f681f553cc0f94002adf5cdebc"></a><!-- doxytag: member="mergesort_cta.cuh::lin_search_block" ref="gaff88a7f681f553cc0f94002adf5cdebc" args="(T &amp;cmpValue, T mVal, unsigned int &amp;tmpVal, T *in, unsigned int *addressPad, unsigned int &amp;j, unsigned int offset, unsigned int last, unsigned int startAddress, unsigned int addPart)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void lin_search_block </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cmpValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>tmpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>addressPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addPart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linear search within a single block (blockSort) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cmpValue</td><td>Value being considered from other partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mVal</td><td>Value in our partition </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tmpVal</td><td>Temporary register which is used to store the final address after our search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in,addressPad,in</td><td>= keys and addressPad = values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index in B partition we are considering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Since this is register packed, offset is the ith iteration of linear search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The end of partition B we are allowed to look upto </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>The beginning of our partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addPart</td><td>Tie break (left partition vs right partition) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86edc089459ae4161acd99f39e86aa7b"></a><!-- doxytag: member="mergesort_cta.cuh::compareSwapVal" ref="ga86edc089459ae4161acd99f39e86aa7b" args="(T &amp;A1, T &amp;A2, unsigned int &amp;ref1, unsigned int &amp;ref2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void compareSwapVal </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>A1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>A2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>ref1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>ref2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For blockSort. Compares two values and decides to swap if A1 &gt; A2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A1</td><td>First value being compared </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A2</td><td>Second value being compared </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref1</td><td>Local address of A1 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref2</td><td>Local address of A2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac422d7926d1644cb4c309b3c57ca9763"></a><!-- doxytag: member="mergesort_cta.cuh::linearMerge_lower" ref="gac422d7926d1644cb4c309b3c57ca9763" args="(T *searchArray, T myKey, unsigned int myVal, int &amp;index, T *saveGlobalArray, unsigned int *saveValueArray, int myStartIdxC, T nextMaxB, int localAPartSize, int localBPartSize, T localMaxB, T localMinB, int aIndex, int bIndex, int offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void linearMerge_lower </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>searchArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>myKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>myVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>saveGlobalArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>saveValueArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myStartIdxC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>nextMaxB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localAPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localBPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>localMaxB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>localMinB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a linear search in our shared memory (done after binary search). It merges the partition on the left side with the associated partition on the right side. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchArray</td><td>Array of keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myKey</td><td>Current key being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myVal</td><td>Associated value of key </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Index in local B partition we are comparing with </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saveGlobalArray</td><td>Array of Keys after merge is complete </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saveValueArray</td><td>Array of values after merge is complete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myStartIdxC</td><td>Global starting index of both partitions being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextMaxB</td><td>Minimum value in the partition NEXT to the one we are comparing against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localAPartSize</td><td>Size of the partition we are considering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localBPartSize</td><td>Size of the partition we are comparing against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localMaxB</td><td>Largest element in THIS partition we are comparing against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localMinB</td><td>Smallest element in THIS partition we are comparing against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>The first global index our block is considering (thread 0 key 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bIndex</td><td>The first global index our block is comparing against (value 0 in shared memory) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Count of key this thread is considering (between 1 and depth) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89e615395989d354aa30c5875543e762"></a><!-- doxytag: member="mergesort_cta.cuh::linearMerge_higher" ref="ga89e615395989d354aa30c5875543e762" args="(T *searchArray, T myKey, unsigned int myVal, int &amp;index, T *saveGlobalArray, unsigned int *saveValueArray, int myStartIdxC, T localMinB, T nextMaxB, int aIndex, int bIndex, int offset, int localAPartSize, int localBPartSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void linearMerge_higher </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>searchArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>myKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>myVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>saveGlobalArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>saveValueArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myStartIdxC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>localMinB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>nextMaxB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localAPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localBPartSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a linear search in our shared memory (done after binary search). It merges the partition on the right side with the associated partition on the left side. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchArray</td><td>Array of keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myKey</td><td>Current key being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myVal</td><td>Associated value of key </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Index in local B partition we are comparing with </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saveGlobalArray</td><td>Array of Keys after merge is complete </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saveValueArray</td><td>Array of values after merge is complete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myStartIdxC</td><td>Global starting index of both partitions being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localMinB</td><td>Smallest element in THIS partition we are comparing against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextMaxB</td><td>Minimum value in the partition NEXT to the one we are comparing against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>The first global index our block is considering (thread 0 key 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bIndex</td><td>The first global index our block is comparing against (value 0 in shared memory) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Count of key this thread is considering (between 1 and depth) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localAPartSize</td><td>Size of the partition we are considering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localBPartSize</td><td>Size of the partition we are comparing against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga05ad3c672e73b35a200893881f3d1cd2"></a><!-- doxytag: member="radixsort_cta.cuh::floatFlip" ref="ga05ad3c672e73b35a200893881f3d1cd2" args="(uint f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool doFlip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint floatFlip </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flips bits of single-precision floating-point number (parameterized by doFlip) </p>
<p>flip a float for sorting finds SIGN of fp number. if it's 1 (negative float), it flips all bits if it's 0 (positive float), it flips the sign only </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>floating-point input (passed as unsigned int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uint that stores the flipped version of the input </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga3cf28e5904a54e10af2d1c3fea729a59" title="Reverses bit-flip of single-precision floating-point number (parameterized by doFlip)">floatUnflip</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3cf28e5904a54e10af2d1c3fea729a59"></a><!-- doxytag: member="radixsort_cta.cuh::floatUnflip" ref="ga3cf28e5904a54e10af2d1c3fea729a59" args="(uint f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool doFlip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint floatUnflip </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses bit-flip of single-precision floating-point number (parameterized by doFlip) </p>
<p>flip a float back (invert FloatFlip) signed was flipped from above, so: if sign is 1 (negative), it flips the sign bit back if sign is 0 (positive), it flips all bits back </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>floating-point input (passed as unsigned int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uint that stores the unflipped version of the input </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga05ad3c672e73b35a200893881f3d1cd2" title="Flips bits of single-precision floating-point number (parameterized by doFlip)">floatFlip</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5328c4100b48f78b8ae2b11126ae241b"></a><!-- doxytag: member="radixsort_cta.cuh::scanwarp" ref="ga5328c4100b48f78b8ae2b11126ae241b" args="(T val, volatile T *sData)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int maxlevel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ T scanwarp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>sData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scans one warp quickly, optimized for 32-element warps, using shared memory. </p>
<p>Scans each warp in parallel ("warp-scan"), one element per thread. uses 2 numElements of shared memory per thread (64 numElements per warp)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Elements per thread to scan </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sData</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Scanned input warp </dd></dl>

</div>
</div>
<a class="anchor" id="gabfa515588187af6524cbfd4d76fd16c5"></a><!-- doxytag: member="radixsort_cta.cuh::scan4" ref="gabfa515588187af6524cbfd4d76fd16c5" args="(uint4 idata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint4 scan4 </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>idata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scans 4*CTA_SIZE unsigned ints in a block. </p>
<p>scan4 scans 4*CTA_SIZE numElements in a block (4 per thread), using a warp-scan algorithm</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idata</td><td>4-vector of integers to scan </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Scanned input 4-vector of integers </dd></dl>

</div>
</div>
<a class="anchor" id="gac598a1e6647cdfdb14ab24d0411ad1f5"></a><!-- doxytag: member="radixsort_cta.cuh::rank4" ref="gac598a1e6647cdfdb14ab24d0411ad1f5" args="(uint4 preds)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ctasize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint4 rank4 </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>preds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes output position for each thread given predicate; trues come first then falses. </p>
<p>Rank is the core of the radix sort loop. Given a predicate, it computes the output position for each thread in an ordering where all True threads come first, followed by all False threads. This version handles 4 predicates per thread; hence, "rank4".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">preds</td><td>true/false values for each of the 4 elements in this thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Output position for each thread</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>is the description of "preds" correct? </dd></dl>

</div>
</div>
<a class="anchor" id="gad6197a166da7197ec317c4373a8ff232"></a><!-- doxytag: member="radixsort_cta.cuh::radixSortBlock" ref="gad6197a166da7197ec317c4373a8ff232" args="(uint4 &amp;key, uint4 &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void radixSortBlock </td>
          <td>(</td>
          <td class="paramtype">uint4 &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts one block. </p>
<p>Uses rank to sort one bit at a time: Sorts a block according to bits startbit -&gt; nbits + startbit </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Sorted key/value block with respect to startbit and nbits </dd></dl>

</div>
</div>
<a class="anchor" id="ga8927705927517481e2115784a2bf1876"></a><!-- doxytag: member="radixsort_cta.cuh::radixSortBlockKeysOnly" ref="ga8927705927517481e2115784a2bf1876" args="(uint4 &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void radixSortBlockKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint4 &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts one block. Key-only version. </p>
<p>Uses rank to sort one bit at a time: Sorts a block according to bits startbit -&gt; nbits + startbit </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Sorted key-only block with respect to startbit and nbits </dd></dl>

</div>
</div>
<a class="anchor" id="ga13c90ad7137a333b8ad2d3ccbb447fef"></a><!-- doxytag: member="rand_cta.cuh::swizzleShift" ref="ga13c90ad7137a333b8ad2d3ccbb447fef" args="(uint4 *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void swizzleShift </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx. </p>
<p>It does the equvalent of f-&gt;xyzw = f-&gt;yzwx since this functionality is in shading languages but not exposed in CUDA. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the uint4 data type which will have its elements shifted. Passed in as pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6139c8e2423bd271815ffb6feb572080"></a><!-- doxytag: member="rand_cta.cuh::leftRotate" ref="ga6139c8e2423bd271815ffb6feb572080" args="(unsigned int x, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int leftRotate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the bits in <em>x</em> over by <em>n</em> bits. </p>
<p>This is the equivalent of the ROTATELEFT operation as described in the MD5 working memo. It takes the bits in <em>x</em> and circular shifts it over by <em>n</em> bits.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the variable with the bits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of bits to shift left by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rotated input </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6d7ad89002d2bc4ea5dfda74c5044c0"></a><!-- doxytag: member="rand_cta.cuh::F" ref="gaf6d7ad89002d2bc4ea5dfda74c5044c0" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int F </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The F scrambling function. </p>
<p>The F function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:</p>
<p>(x &amp; y) | ((~x) &amp; z)</p>
<p>The resulting value is returned as an unsigned int.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>See the above formula </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>F(x, y, z)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga441b30dd5f34b0f92a826e2835a2924b" title="The FF scrambling function.">FF()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga903661679dd9f375fc6cfbcb285f39b1"></a><!-- doxytag: member="rand_cta.cuh::G" ref="ga903661679dd9f375fc6cfbcb285f39b1" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int G </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The G scrambling function. </p>
<p>The G function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:</p>
<p>(x &amp; z) | ((~z) &amp; y)</p>
<p>The resulting value is returned as an unsigned int.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>See the above formula </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>G(x, y, z)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga45ddf2b6f6e2a98ce150f592ba32d3fa" title="The GG scrambling function.">GG()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga573bcce88a259368f3c2025371bdf656"></a><!-- doxytag: member="rand_cta.cuh::H" ref="ga573bcce88a259368f3c2025371bdf656" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int H </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The H scrambling function. </p>
<p>The H function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:</p>
<p>(x ^ y ^ z)</p>
<p>The resulting value is returned as an unsigned int.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>See the above formula </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>H(x, y, z)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#gafa4aefc8ed889545483f0686a5da016f" title="The HH scrambling function.">HH()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2de48c1f68ee34f9943390241961fb2"></a><!-- doxytag: member="rand_cta.cuh::I" ref="gaf2de48c1f68ee34f9943390241961fb2" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int I </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The I scrambling function. </p>
<p>The I function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:</p>
<p>(y ^ (x | ~z))</p>
<p>The resulting value is returned as an unsigned int.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>See the above formula </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>See the above formula </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>I(x, y, z)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga19d04cb1fa018499b6f5ef3a873bdd50" title="The II scrambling function.">II()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga441b30dd5f34b0f92a826e2835a2924b"></a><!-- doxytag: member="rand_cta.cuh::FF" ref="ga441b30dd5f34b0f92a826e2835a2924b" args="(uint4 *td, int i, uint4 *Fr, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void FF </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>Fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The FF scrambling function. </p>
<p>The FF function in the MD5 technical memo is a wrapper for the F scrambling function as well as performing its own rotations using LeftRotate and swizzleShift. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Fr</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">td</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fr</td><td>The current rotation order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The constant 2^32. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FF(input)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#gaf6d7ad89002d2bc4ea5dfda74c5044c0" title="The F scrambling function.">F()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga45ddf2b6f6e2a98ce150f592ba32d3fa"></a><!-- doxytag: member="rand_cta.cuh::GG" ref="ga45ddf2b6f6e2a98ce150f592ba32d3fa" args="(uint4 *td, int i, uint4 *Gr, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void GG </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>Gr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The GG scrambling function. </p>
<p>The GG function in the MD5 technical memo is a wrapper for the G scrambling function as well as performing its own rotations using LeftRotate() and <a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a>. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Gr</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">td</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Gr</td><td>The current rotation order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The constant 2^32. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>GG(input)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga903661679dd9f375fc6cfbcb285f39b1" title="The G scrambling function.">G()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa4aefc8ed889545483f0686a5da016f"></a><!-- doxytag: member="rand_cta.cuh::HH" ref="gafa4aefc8ed889545483f0686a5da016f" args="(uint4 *td, int i, uint4 *Hr, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void HH </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>Hr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The HH scrambling function. </p>
<p>The HH function in the MD5 technical memo is a wrapper for the H scrambling function as well as performing its own rotations using LeftRotate() and <a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a>. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Hr</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">td</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Hr</td><td>The current rotation order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The constant 2^32. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>HH(input)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga573bcce88a259368f3c2025371bdf656" title="The H scrambling function.">H()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga19d04cb1fa018499b6f5ef3a873bdd50"></a><!-- doxytag: member="rand_cta.cuh::II" ref="ga19d04cb1fa018499b6f5ef3a873bdd50" args="(uint4 *td, int i, uint4 *Ir, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void II </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>Ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The II scrambling function. </p>
<p>The II function in the MD5 technical memo is a wrapper for the I scrambling function as well as performing its own rotations using LeftRotate() and <a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a>. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Ir</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">td</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ir</td><td>The current rotation order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The constant 2^32. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>II(input)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#gaf2de48c1f68ee34f9943390241961fb2" title="The I scrambling function.">I()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#gad815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad815ed3373fd7ed8be004190d392a429"></a><!-- doxytag: member="rand_cta.cuh::setupInput" ref="gad815ed3373fd7ed8be004190d392a429" args="(unsigned int *input, unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void setupInput </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up the <em>input</em> array using information of <em>seed</em>, and <em>threadIdx</em>. </p>
<p>This function sets up the <em>input</em> array using a combination of the current thread's id and the user supplied <em>seed</em>.</p>
<p>For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">input</td><td>The array which will contain the initial values for all the scrambling functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The user supplied seed as an unsigned int.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#ga441b30dd5f34b0f92a826e2835a2924b" title="The FF scrambling function.">FF()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga45ddf2b6f6e2a98ce150f592ba32d3fa" title="The GG scrambling function.">GG()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#gafa4aefc8ed889545483f0686a5da016f" title="The HH scrambling function.">HH()</a> </dd>
<dd>
<a class="el" href="group__cudpp__cta.html#ga19d04cb1fa018499b6f5ef3a873bdd50" title="The II scrambling function.">II()</a> </dd>
<dd>
<a class="el" href="group__cudpp__kernel.html#gaa69e40f48791d63cdd66d101a22f6a4a" title="The main MD5 generation algorithm.">gen_randMD5()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabccbcb560a7006c22db2aada19d37051"></a><!-- doxytag: member="scan_cta.cuh::loadSharedChunkFromMem4" ref="gabccbcb560a7006c22db2aada19d37051" args="(T *s_out, T threadScan[2][4], const T *d_in, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void loadSharedChunkFromMem4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan</em>[2][4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>biDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles loading input s_data from global memory to shared memory (vec4 version) </p>
<p>Load a chunk of 8*blockDim.x elements from global memory into a shared memory array. Each thread loads two T4 elements (where T4 is, e.g. int4 or float4), computes the scan of those two vec4s in thread local arrays (in registers), and writes the two total sums of the vec4s into shared memory, where they will be cooperatively scanned with the other partial sums by all threads in the CTA.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s_out</td><td>The output (shared) memory array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadScan</td><td>Intermediate per-thread partial sums array (x2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input (device) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iDataOffset</td><td>the offset of the input array in global memory for this thread block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ai</td><td>The shared memory address for the thread's first element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bi</td><td>The shared memory address for the thread's second element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aiDev</td><td>The device memory address for this thread's first element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">biDev</td><td>The device memory address for this thread's second element (returned for reuse) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77ee3d4998aa155a93b1c0af5814d5ba"></a><!-- doxytag: member="scan_cta.cuh::storeSharedChunkToMem4" ref="ga77ee3d4998aa155a93b1c0af5814d5ba" args="(T *d_out, T threadScan[2][4], T *s_in, int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void storeSharedChunkToMem4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan</em>[2][4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>biDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles storing result s_data from shared memory to global memory (vec4 version) </p>
<p>Store a chunk of SCAN_ELTS_PER_THREAD*blockDim.x elements from shared memory into a device memory array. Each thread stores reads two elements from shared memory, adds them to the intermediate sums computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>, and writes two T4 elements (where T4 is, e.g. int4 or float4) to global memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output (device) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadScan</td><td>Intermediate per-thread partial sums array (x2) (contents computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_in</td><td>The input (shared) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oDataOffset</td><td>the offset of the output array in global memory for this thread block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>The shared memory address for the thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bi</td><td>The shared memory address for the thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiDev</td><td>The device memory address for this thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biDev</td><td>The device memory address for this thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga19caab62e5c027ea3fff08cb15d0efbf"></a><!-- doxytag: member="scan_cta.cuh::loadSharedChunkFromMem2" ref="ga19caab62e5c027ea3fff08cb15d0efbf" args="(T *s_out, T threadScan[2][2], const T *d_in, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void loadSharedChunkFromMem2 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>biDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles loading input s_data from global memory to shared memory (vec4 version) </p>
<p>Load a chunk of 8*blockDim.x elements from global memory into a shared memory array. Each thread loads two T4 elements (where T4 is, e.g. int4 or float4), computes the scan of those two vec4s in thread local arrays (in registers), and writes the two total sums of the vec4s into shared memory, where they will be cooperatively scanned with the other partial sums by all threads in the CTA.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s_out</td><td>The output (shared) memory array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadScan</td><td>Intermediate per-thread partial sums array (x2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input (device) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iDataOffset</td><td>the offset of the input array in global memory for this thread block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ai</td><td>The shared memory address for the thread's first element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bi</td><td>The shared memory address for the thread's second element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aiDev</td><td>The device memory address for this thread's first element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">biDev</td><td>The device memory address for this thread's second element (returned for reuse) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae2d034aecf8335b4878982afff2a8224"></a><!-- doxytag: member="scan_cta.cuh::storeSharedChunkToMem2" ref="gae2d034aecf8335b4878982afff2a8224" args="(T *d_out, T threadScan[2][2], T *s_in, int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void storeSharedChunkToMem2 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>biDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles storing result s_data from shared memory to global memory (vec4 version) </p>
<p>Store a chunk of SCAN_ELTS_PER_THREAD*blockDim.x elements from shared memory into a device memory array. Each thread stores reads two elements from shared memory, adds them to the intermediate sums computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>, and writes two T4 elements (where T4 is, e.g. int4 or float4) to global memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output (device) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadScan</td><td>Intermediate per-thread partial sums array (x2) (contents computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_in</td><td>The input (shared) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oDataOffset</td><td>the offset of the output array in global memory for this thread block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>The shared memory address for the thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bi</td><td>The shared memory address for the thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiDev</td><td>The device memory address for this thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biDev</td><td>The device memory address for this thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gabccbcb560a7006c22db2aada19d37051" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadSharedChunkFromMem4()</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e02e951efac2a6fba038cd102ef0415"></a><!-- doxytag: member="scan_cta.cuh::warpscan" ref="ga2e02e951efac2a6fba038cd102ef0415" args="(T val, volatile T *s_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits , int maxlevel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ T warpscan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>s_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan all warps of a CTA without synchronization. </p>
<p>The warp-scan algorithm breaks a block of data into warp-sized chunks, and scans the chunks independently with a warp of threads each. Because warps execute instructions in SIMD fashion, there is no need to synchronize in order to share data within a warp (only across warps). Also, in SIMD the most efficient algorithm is a step-efficient algorithm. Therefore, within each warp we use a Hillis-and-Steele-style scan that takes log2(N) steps to scan the warp [Daniel Hillis and Guy Steele 1986], rather than the work-efficient tree-based algorithm described by Guy Blelloch [1990] that takes 2 * log(N) steps and is in general more complex to implement. Previous versions of CUDPP used the Blelloch algorithm. For current GPUs, the warp size is 32, so this takes five steps per warp.</p>
<p>Each thread is responsible for a single element of the array to be scanned. Each thread inputs a single value to the scan via <em>val</em> and returns its own scanned result element. The threads of each warp cooperate via the shared memory array <em>s_data</em> to scan WARP_SIZE elements.</p>
<p>Template parameter <em>maxlevel</em> allows this warpscan to be performed on partial warps. For example, if only the first 8 elements of each warp need to be scanned, then warpscan only performs log2(8)=3 steps rather than 5.</p>
<p>The computation uses 2 * WARP_SIZE elements of shared memory per warp to enable warps to offset beyond their input data and receive the identity element without using any branch instructions.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>s_data is declared volatile here to prevent the compiler from optimizing away writes to shared memory, and ensure correct intrawarp communication in the absence of __syncthreads.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of the warp scan for the current thread </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The current threads's input to the scan </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s_data</td><td>A pointer to a temporary shared array of 2*CTA_SIZE elements used to compute the warp scans </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga163e1d81b5e290f00dcdf77060bc5c40"></a><!-- doxytag: member="scan_cta.cuh::scanWarps" ref="ga163e1d81b5e290f00dcdf77060bc5c40" args="(T x, T y, T *s_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void scanWarps </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a full CTA scan using the warp-scan algorithm. </p>
<p>As described in the comment for <a class="el" href="group__cudpp__cta.html#ga2e02e951efac2a6fba038cd102ef0415" title="Scan all warps of a CTA without synchronization.">warpscan()</a>, the warp-scan algorithm breaks a block of data into warp-sized chunks, and scans the chunks independently with a warp of threads each. To complete the scan, each warp <em>j</em> then writes its last element to element <em>j</em> of a temporary shared array. Then a single warp exclusive-scans these "warp sums". Finally, each thread adds the result of the warp sum scan to the result of the scan from the first pass.</p>
<p>Because we scan 2*CTA_SIZE elements per thread, we have to call warpscan twice.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first input value for the current thread </td></tr>
    <tr><td class="paramname">y</td><td>The second input value for the current thread </td></tr>
    <tr><td class="paramname">s_data</td><td>Temporary shared memory space of 2*CTA_SIZE elements for performing the scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac39bd4553f352fb03361a56b17be04ee"></a><!-- doxytag: member="scan_cta.cuh::scanCTA" ref="gac39bd4553f352fb03361a56b17be04ee" args="(T *s_data, T *d_blockSums, unsigned int blockSumIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void scanCTA </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blockSumIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CTA-level scan routine; scans s_data in shared memory in each thread block. </p>
<p>This function is the main CTA-level scan function. It may be called by other CUDA __global__ or __device__ functions. This function scans 2 * CTA_SIZE elements. Each thread is responsible for one element in each half of the input array. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This code is intended to be run on a CTA of 128 threads. Other sizes are untested.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s_data</td><td>The array to be scanned in shared memory </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of per-block sums </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSumIndex</td><td>Location in <em>d_blockSums</em> to which to write this block's sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf417327731b668f89a1a8a32ae715e63"></a><!-- doxytag: member="segmented_scan_cta.cuh::loadForSegmentedScanSharedChunkFromMem4" ref="gaf417327731b668f89a1a8a32ae715e63" args="(T *s_odata, T threadScan0[4], T threadScan1[4], unsigned int &amp;threadFlag, unsigned int *s_oflags, unsigned int *s_oindices, const T *d_idata, const unsigned int *d_iflags, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void loadForSegmentedScanSharedChunkFromMem4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan0</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan1</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>threadFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>s_oflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>s_oindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>biDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles loading input s_data from global memory to shared memory (vec4 version) </p>
<p>Load a chunk of 8*blockDim.x elements from global memory into a shared memory array. Each thread loads two T4 elements (where T4 is, e.g. int4 or float4), computes the segmented scan of those two vec4s in thread local arrays (in registers), and writes the two total sums of the vec4s into shared memory, where they will be cooperatively scanned with the other partial sums by all threads in the CTA.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s_odata</td><td>The output (shared) memory array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadScan0</td><td>Intermediate per-thread partial sums array 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadScan1</td><td>Intermediate per-thread partial sums array 2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadFlag</td><td>Intermediate array which holds 8 flags as follows Temporary register threadFlag0[4] - the flags for the first 4 elements read Temporary register threadFlag1[4] - the flags for the second 4 elements read Temporary register threadScanFlag0[4] - the inclusive OR-scan for the flags in threadFlag0[4] Temporary register threadScanFlag1[4] - the inclusive OR-scan for the flags in threadFlag1[4] We storing the 16 flags 32 bits of threadFlag Bits 0...3 contains threadFlag0[0]...threadFlag0[3] Bits 4...7 contains threadFlag1[0]...threadFlag1[3] Bits 8...11 contains threadScanFlag0[0]...threadScanFlag0[3] Bits 11...15 contains threadScanFlag1[0]...threadScanFlag1[3] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s_oflags</td><td>Output (shared) memory array of segment head flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s_oindices</td><td>Output (shared) memory array of indices. If a flag for a position (1-based) is set then index for that position is the position, 0 otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>The input (device) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>The input (device) memory array of segment head flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iDataOffset</td><td>the offset of the input array in global memory for this thread block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ai</td><td>The shared memory address for the thread's first element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bi</td><td>The shared memory address for the thread's second element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aiDev</td><td>The device memory address for this thread's first element (returned for reuse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">biDev</td><td>The device memory address for this thread's second element (returned for reuse) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab970a2f1d36591efe8376d8a1eaf2964"></a><!-- doxytag: member="segmented_scan_cta.cuh::storeForSegmentedScanSharedChunkToMem4" ref="gab970a2f1d36591efe8376d8a1eaf2964" args="(T *d_odata, T threadScan0[4], T threadScan1[4], unsigned int threadFlag, T *s_idata, unsigned int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void storeForSegmentedScanSharedChunkToMem4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan0</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threadScan1</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>threadFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>biDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles storing result s_data from shared memory to global memory (vec4 version) </p>
<p>Store a chunk of 8*blockDim.x elements from shared memory into a device memory array. Each thread stores reads two elements from shared memory, adds them while respecting segment bouldaries, to the intermediate sums computed in <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a>, and writes two T4 elements (where T4 is, e.g. int4 or float4) to global memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_odata</td><td>The output (device) memory array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadScan0</td><td>Intermediate per-thread partial sums array 1 (contents computed in <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadScan1</td><td>Intermediate per-thread partial sums array 2 (contents computed in <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadFlag</td><td>Various flags that <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a> needs to pass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_idata</td><td>The input (shared) memory array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oDataOffset</td><td>the offset of the output array in global memory for this thread block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>The shared memory address for the thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bi</td><td>The shared memory address for the thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiDev</td><td>The device memory address for this thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biDev</td><td>The device memory address for this thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gaf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version)">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1e22f2750f80d47cab975543f6afed40"></a><!-- doxytag: member="segmented_scan_cta.cuh::segmentedScanCTA" ref="ga1e22f2750f80d47cab975543f6afed40" args="(T *s_data, unsigned int *s_flags, unsigned int *s_indices, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void segmentedScanCTA </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>s_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>s_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CTA-level segmented scan routine;. </p>
<p>Performs segmented scan on <em>s_data</em> in shared memory in each thread block with head flags in <em>s_flags</em> (<em>s_tflags</em> is a read-write copy of the head flags which are modified).</p>
<p>This function is the main CTA-level segmented scan function. It may be called by other CUDA __global__ or __device__ functions. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This code is intended to be run on a CTA of 128 threads. Other sizes are untested.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s_data</td><td>Array to be scanned in shared memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_flags</td><td>Read-only version of flags in shared memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_indices</td><td>Temporary read-write indices array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of per-block sums </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockFlags</td><td>Array of per-block OR-reduction of flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockIndices</td><td>Array of per-block min-reduction of indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad87bcb57897cfbc6a5d46b9e9a38347c"></a><!-- doxytag: member="stringsort_cta.cuh::tie_break_simp" ref="gad87bcb57897cfbc6a5d46b9e9a38347c" args="(unsigned int myLoc, unsigned int cmpLoc, unsigned int myBound, unsigned int cmpBound, unsigned int myAdd, unsigned int cmpAdd, unsigned int *stringLoc, unsigned int stringSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ int tie_break_simp </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>myLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>myBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>myAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>stringLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Breaks ties in keys (first four characters) returns true if cmpVal &gt; myVal false otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">myLoc,cmpLoc</td><td>Location of the two inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myBound,cmpBound</td><td>Local memory bounds for the two addresses </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myAdd</td><td>Address into global memory of our current value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmpAdd</td><td>Address into global memory of the value we are comparing against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringLoc</td><td>Global memory array (input string) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>Size of our input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 if cmpVal &gt; myVal 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d5a6f0061060d315186eec3055086f7"></a><!-- doxytag: member="stringsort_cta.cuh::bin_search_block_string" ref="ga2d5a6f0061060d315186eec3055086f7" args="(T &amp;cmpValue, T tmpVal, T *in, T *addressPad, T *stringVals, int &amp;j, int bump, int sizeRemain, unsigned int stringSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void bin_search_block_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cmpValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tmpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addressPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bump</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeRemain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binary search within a single block (blockSort) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cmpValue</td><td>Value being considered from other partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmpVal</td><td>My Value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressPad</td><td>addresses of string locations in case of tie breaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>global string array used to break ties </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">j</td><td>The index we are considering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bump</td><td>The offset we update by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeRemain</td><td>Size of our block (if it's smaller than blockSize) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>Size of our global string array (for tie breaks) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaed1b743ff0e294651bfc2372d94ce43d"></a><!-- doxytag: member="stringsort_cta.cuh::lin_search_block_string" ref="gaed1b743ff0e294651bfc2372d94ce43d" args="(T &amp;cmpValue, T &amp;tmpVal, T *in, T *addressPad, T *stringVals, int &amp;j, int offset, int last, int startAddress, int stringSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void lin_search_block_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cmpValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tmpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addressPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linear search within a single block (blockSort) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cmpValue</td><td>Value being considered from other partition </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tmpVal</td><td>Temporary register which is used initially to compare our value, and then to store the final address after our search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in,addressPad,stringVals</td><td>in = keys, addressPad = values, stringVals = global string array for tie breaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index in B partition we are considering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Since this is register packed, offset is the ith iteration of linear search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The end of partition B we are allowed to look upto </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>The beginning of our partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>Size of our global string array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97b5616a860f477c61b8f97608cd2f4a"></a><!-- doxytag: member="stringsort_cta.cuh::compareSwapVal" ref="ga97b5616a860f477c61b8f97608cd2f4a" args="(T &amp;A1, T &amp;A2, const int index1, const int index2, T *scratch, T *stringVals, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void compareSwapVal </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>A1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>A2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For blockSort. Compares two values and decides to swap if A1 &gt; A2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A1</td><td>First value being compared </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A2</td><td>Second value being compared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index1</td><td>Local address of A1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index2</td><td>Local address of A2 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">scratch</td><td>Scratch memory storing the addresses </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>String Values for tie breaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of our array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2ecd3f50362c357eb88c37fdf5be8a4c"></a><!-- doxytag: member="stringsort_cta.cuh::binSearch_fragment" ref="ga2ecd3f50362c357eb88c37fdf5be8a4c" args="(T *keys, T *address, int offset, int &amp;mid, T cmpValue, T testValue, T myAddress, int myLoc, int cmpLoc, int myBound, int cmpBound, T *globalStringArray, int stringSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void binSearch_fragment </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>cmpValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>testValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>myAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>globalStringArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a binary search in our shared memory, with tie breaks for strings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys,address</td><td>Keys and address from our array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset,mid</td><td>The current "middle" we are searching and the offset we will move to next </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmpValue,testValue</td><td>testValue is the value we are searching for from array A, cmpValue the value we have currently in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myAddress,myLoc,cmpLoc,myBound,cmpBound</td><td>Same values from tie_break_simp which will be passed along </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">globalStringArray,stringSize</td><td>Our string array for breaking ties, and stringSize so we don't go out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga624550c4d768492aab1eab134d4de0eb"></a><!-- doxytag: member="stringsort_cta.cuh::lin_merge_simple" ref="ga624550c4d768492aab1eab134d4de0eb" args="(T &amp;cmpValue, T myKey, T myAddress, int &amp;index, T *BKeys, T *BValues, T *stringValues, T *A_keys, T *A_values, T *A_keys_out, T *A_values_out, int myStartIdxA, int myStartIdxB, int myStartIdxC, T localMinB, T localMaxB, int aCont, int bCont, int totalSize, int mySizeA, int mySizeB, unsigned int stringSize, int i, int stepNum, bool &amp;placed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void lin_merge_simple </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>cmpValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>myKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>myAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>BKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>BValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myStartIdxA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myStartIdxB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myStartIdxC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>localMinB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>localMaxB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bCont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>totalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mySizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mySizeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stepNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>placed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a linear search in our shared memory (done after binary search), with tie breaks for strings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cmpValue</td><td>The current value we are looking at in our B array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myKey,myAddress</td><td>Keys and address from our array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Current index we are considering in our B array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BKeys,BValues</td><td>Keys and Addresses for array B </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">stringValues,A_keys,A_values,A_keys_out,A_values_out</td><td>Global arrays for our strings, keys, values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myStartIdxA,myStartIdxB,myStartIdxC</td><td>Beginning indices for our partitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localMinB,localMaxB</td><td>The minimum and maximum values in our B partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aCont,bCont,totalSize,mySizeA,mySizeB,stringSize</td><td>Address bounds and calculation helpers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of the local element we are merging </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepNum</td><td>Debug helper </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">placed</td><td>Whether value has been placed yet or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Mar 8 2013 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
