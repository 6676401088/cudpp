<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Kernel-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">2.0</span></div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">CUDPP Kernel-Level API</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga02aca9cfcac6799d445c857626e7d317">compactData</a> (T *d_out, size_t *d_numValidElements, const unsigned int *d_indices, const unsigned int *d_isValid, const T *d_in, unsigned int numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Consolidate non-null elements - for each non-null element in <em>d_in</em> write it to <em>d_out</em>, in the position specified by <em>d_isValid</em>. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.  <a href="#ga02aca9cfcac6799d445c857626e7d317"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Compress Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_kernel::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65f85814a8290f9797005d3b28e7e5fc"></a><!-- doxytag: member="cudpp_kernel::uchar" ref="ga65f85814a8290f9797005d3b28e7e5fc" args="" -->
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>uchar</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab95f123a6c9bcfee6a343170ef8c5f69"></a><!-- doxytag: member="cudpp_kernel::ushort" ref="gab95f123a6c9bcfee6a343170ef8c5f69" args="" -->
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>ushort</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga76ac9f96df0a5fc0f9e8c1fb3342224c">bwt_compute_final_kernel</a> (const uchar *d_bwtIn, const uint *d_values, int *d_bwtIndex, uchar *d_bwtOut, uint numElements, uint tThreads)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute final BWT.  <a href="#ga76ac9f96df0a5fc0f9e8c1fb3342224c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga00ebfa85a812d1939aa6c32364969caf">stringMergeMulti</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int *partitionBeginB, int *partitionSizeB, int entirePartitionSize, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi merge.  <a href="#ga00ebfa85a812d1939aa6c32364969caf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga06344caed45b6f9b8149e1df413dda05">findMultiPartitions</a> (T *A, int splitsPP, int numPartitions, int partitionSize, int *partitionBeginA, int *partitionSizesA, int *partitionBeginB, int *partitionSizesB, int sizeA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "upper" block (right block)  <a href="#ga06344caed45b6f9b8149e1df413dda05"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga97296735e5a622fef963eeb31f334d60">simpleStringMerge</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int sizePerPartition, int size, T *stringValues2, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple merge.  <a href="#ga97296735e5a622fef963eeb31f334d60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga547123dc3e249d228eaf834e4259b4a9">blockWiseStringSort</a> (T *A_keys, T *A_address, const T *stringVals, T *stringVals2, int blockSize, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts blocks of data of size blockSize.  <a href="#ga547123dc3e249d228eaf834e4259b4a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga9d05a5c631bc48626934620fb72b3b39">bwt_keys_construct_kernel</a> (uchar4 *d_bwtIn, uint *d_bwtInRef, uint *d_keys, uint *d_values, uint *d_bwtInRef2, uint tThreads)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Massage input to set up for merge sort.  <a href="#ga9d05a5c631bc48626934620fb72b3b39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga6d72d588b31baf58068a337d13bb603f">mtf_reduction_kernel</a> (const uchar *d_mtfIn, uchar *d_lists, ushort *d_list_sizes, uint nLists, uint offset, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">First stage in MTF (Reduction)  <a href="#ga6d72d588b31baf58068a337d13bb603f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gab9ee105a921c3c45a883904eaf1bbd8c">mtf_GLreduction_kernel</a> (uchar *d_lists, ushort *d_list_sizes, uint offset, uint tThreads, uint nLists)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Second stage in MTF (Global reduction)  <a href="#gab9ee105a921c3c45a883904eaf1bbd8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga891303a3d2ac4bc37055100434f107d3">mtf_GLdownsweep_kernel</a> (uchar *d_lists, ushort *d_list_sizes, uint offset, uint lastLevel, uint nLists, uint tThreads)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Third stage in MTF (Global downsweep)  <a href="#ga891303a3d2ac4bc37055100434f107d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga40a79948a407885357d3abca1647fc6f">mtf_localscan_lists_kernel</a> (const uchar *d_mtfIn, uchar *d_mtfOut, uchar *d_lists, ushort *d_list_sizes, uint nLists, uint offset, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute final MTF lists and final MTF output.  <a href="#ga40a79948a407885357d3abca1647fc6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga094c75c96eb9efc8ecf1db4798a9cbc1">huffman_build_histogram_kernel</a> (uint *d_input, uint *d_histograms, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 256-entry histogram.  <a href="#ga094c75c96eb9efc8ecf1db4798a9cbc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gac7aec2f652e5e46a5e138cc0f47b5e0a">huffman_build_tree_kernel</a> (const uchar *d_input, uchar *d_huffCodesPacked, uint *d_huffCodeLocations, uchar *d_huffCodeLengths, uint *d_histograms, uint *d_histogram, uint *d_nCodesPacked, uint *d_totalEncodedSize, uint histBlocks, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build Huffman tree/codes.  <a href="#gac7aec2f652e5e46a5e138cc0f47b5e0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga4196de63b3e83a8c85d93e352082c344">huffman_kernel_en</a> (uchar4 *d_input, uchar *d_codes, uint *d_code_locations, uchar *d_huffCodeLengths, encoded *d_encoded, uint nCodesPacked, uint nThreads)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform parallel Huffman encoding.  <a href="#ga4196de63b3e83a8c85d93e352082c344"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga4bda5f1fc2b14ecde1f6e23a87cd0040">huffman_datapack_kernel</a> (encoded *d_encoded, uint *d_encodedData, uint *d_totalEncodedSize, uint *d_eOffsets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack together encoded blocks.  <a href="#ga4bda5f1fc2b14ecde1f6e23a87cd0040"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
ListRank Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_kernel::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65f85814a8290f9797005d3b28e7e5fc"></a><!-- doxytag: member="cudpp_kernel::uchar" ref="ga65f85814a8290f9797005d3b28e7e5fc" args="" -->
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>uchar</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab95f123a6c9bcfee6a343170ef8c5f69"></a><!-- doxytag: member="cudpp_kernel::ushort" ref="gab95f123a6c9bcfee6a343170ef8c5f69" args="" -->
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>ushort</b></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gad5dc7b9fece113b829667acb1dc96fef">list_rank_kernel_soa_1</a> (T *d_ranked_values, const T *d_unranked_values, const int *d_ping, int *d_pong, int *d_start_indices, int step, int head, int numElts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use pointer jumping to rank values. After ranking the values, calculate the next set of indices. The number of values ranked doubles at each kernel call. Called by <a class="el" href="group__cudpp__app.html#ga0429e4ce1e5ab67980778fdcfc58fb63" title="Launch list ranking.">listRank()</a>.  <a href="#gad5dc7b9fece113b829667acb1dc96fef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga91f437989b3d5712b2bf20a124c865ca">list_rank_kernel_soa_2</a> (T *d_ranked_values, const T *d_unranked_values, const int *d_pong, const int *d_start_indices, int head, int numElts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">After pointer jumping is finished and all threads are able to rank values, ranking continues serially. Each thread ranks values until all values are ranked. Called by <a class="el" href="group__cudpp__app.html#ga0429e4ce1e5ab67980778fdcfc58fb63" title="Launch list ranking.">listRank()</a>.  <a href="#ga91f437989b3d5712b2bf20a124c865ca"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
MergeSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_kernel::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga578c7acbdd21a7c5695cf2b165ec62a6">simpleCopy</a> (T *A_keys_dev, unsigned int *A_vals_dev, T *A_keys_out_dev, unsigned int *A_vals_out_dev, int offset, int numElementsToCopy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies unused portions of arrays in our ping-pong strategy.  <a href="#ga578c7acbdd21a7c5695cf2b165ec62a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga19022e91ac930fc986e166a8b6b0becb">blockWiseSort</a> (T *A_keys, unsigned int *A_values, int blockSize, size_t totalSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts blocks of data of size blockSize.  <a href="#ga19022e91ac930fc986e166a8b6b0becb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaf48872f6f68962fbbd9b7024e4b0729d">simpleMerge_lower</a> (T *A_keys, unsigned int *A_values, T *A_keys_out, unsigned int *A_values_out, int sizePerPartition, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "lower" block (left block)  <a href="#gaf48872f6f68962fbbd9b7024e4b0729d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga7a079f7c029d053660662d28eb0f2635">simpleMerge_higher</a> (T *A_keys, unsigned int *A_values, T *A_keys_out, unsigned int *A_values_out, int sizePerPartition, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "upper" block (right block)  <a href="#ga7a079f7c029d053660662d28eb0f2635"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga9946c915483ccf4a767b621aed653da0">findMultiPartitions</a> (T *A, int splitsPP, int numPartitions, int partitionSize, int *partitionBeginA, int *partitionSizesA, int sizeA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indices for the "upper" block (right block)  <a href="#ga9946c915483ccf4a767b621aed653da0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga80c66a64b9094db4a280ee4a2bc14ca8">mergeMulti_lower</a> (T *A_keys_out, unsigned int *A_vals_out, T *A_keys, unsigned int *A_vals, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int entirePartitionSize, int sizeA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks cooperatively Merge two partitions for the indices in the "lower" block (left block)  <a href="#ga80c66a64b9094db4a280ee4a2bc14ca8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga2b9cc399f4dcf17acfa03bb7a078fbe4">mergeMulti_higher</a> (T *A_keys_out, unsigned int *A_vals_out, T *A_keys, unsigned int *A_vals, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int entirePartitionSize, int sizeA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks cooperatively Merge two partitions for the indices in the "upper" block (right block)  <a href="#ga2b9cc399f4dcf17acfa03bb7a078fbe4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_kernel::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9b2c50ca94fbb436128f97475148d84"></a><!-- doxytag: member="cudpp_kernel::emptyKernel" ref="gad9b2c50ca94fbb436128f97475148d84" args="()" -->
__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gad9b2c50ca94fbb436128f97475148d84">emptyKernel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">And empty kernel used to reset CTA issue hardware. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa002e725192c3ac452f6c3168de2895a">flipFloats</a> (uint *values, uint numValues)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does special binary arithmetic before sorting floats.  <a href="#gaa002e725192c3ac452f6c3168de2895a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga359f23566212946fc94d7a61c9e4dfd3">unflipFloats</a> (uint *values, uint numValues)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes the flips from flipFloats.  <a href="#ga359f23566212946fc94d7a61c9e4dfd3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga1c7394659289d6123e477c7b5b3a9e8b">radixSortSingleWarp</a> (uint *keys, uint *values, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of WARP_SIZE or fewer elements.  <a href="#ga1c7394659289d6123e477c7b5b3a9e8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gab4b5a78a353c90d1698b9b7321fa8c9d">radixSortSingleWarpKeysOnly</a> (uint *keys, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of WARP_SIZE or fewer elements. Keys-Only version.  <a href="#gab4b5a78a353c90d1698b9b7321fa8c9d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga2cf5bfc2844ebb31e5859f7ef28cb975">radixSortBlocks</a> (uint4 *keysOut, uint4 *valuesOut, uint4 *keysIn, uint4 *valuesIn, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements  <a href="#ga2cf5bfc2844ebb31e5859f7ef28cb975"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga98fa842d18a6f9d366c1853ee8458426">findRadixOffsets</a> (uint2 *keys, uint *counters, uint *blockOffsets, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of keys of each radix in each block stores offset.  <a href="#ga98fa842d18a6f9d366c1853ee8458426"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga326b66a44772c53ef1657289c511252d">reorderData</a> (uint *outKeys, uint *outValues, uint2 *keys, uint2 *values, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders data in the global array.  <a href="#ga326b66a44772c53ef1657289c511252d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga5266ebf2bb30d8419cea059b1435d475">radixSortBlocksKeysOnly</a> (uint4 *keysOut, uint4 *keysIn, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements.  <a href="#ga5266ebf2bb30d8419cea059b1435d475"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gac8b6736ae3fa13bb852245f054cbd4eb">reorderDataKeysOnly</a> (uint *outKeys, uint2 *keys, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders data in the global array.  <a href="#gac8b6736ae3fa13bb852245f054cbd4eb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Rand Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa69e40f48791d63cdd66d101a22f6a4a">gen_randMD5</a> (uint4 *d_out, size_t numElements, unsigned int seed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main MD5 generation algorithm.  <a href="#gaa69e40f48791d63cdd66d101a22f6a4a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Reduce Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class Oper , unsigned int blockSize, bool nIsPow2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gab64eb250a1594485b1b05a3c1458797d">reduce</a> (T *odata, const T *idata, unsigned int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main reduction kernel.  <a href="#gab64eb250a1594485b1b05a3c1458797d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga68b0aa93e22b1b3fc622ed8d86bc4310">scan4</a> (T *d_out, const T *d_in, T *d_blockSums, int numElements, unsigned int dataRowPitch, unsigned int blockSumRowPitch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main scan kernel.  <a href="#ga68b0aa93e22b1b3fc622ed8d86bc4310"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Segmented scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaf2412fe9c8c1029cadc0d191ccad222f">segmentedScan4</a> (T *d_odata, const T *d_idata, const unsigned int *d_iflags, unsigned int numElements, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main segmented scan kernel.  <a href="#gaf2412fe9c8c1029cadc0d191ccad222f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Sparse Matrix-Vector multiply Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isFullBlock&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gadc255d86178e5e591c3f2d2e8d5f564b">sparseMatrixVectorFetchAndMultiply</a> (unsigned int *d_flags, T *d_prod, const T *d_A, const T *d_x, const unsigned int *d_indx, unsigned int numNZElts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch and multiply kernel.  <a href="#gadc255d86178e5e591c3f2d2e8d5f564b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga650782aef0e14c36782f5c24cd96a8dd">sparseMatrixVectorSetFlags</a> (unsigned int *d_flags, const unsigned int *d_rowindx, unsigned int numRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Flags kernel.  <a href="#ga650782aef0e14c36782f5c24cd96a8dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga01e289bd29d24bfc8e96dd853668900d">yGather</a> (T *d_y, const T *d_prod, const unsigned int *d_rowFindx, unsigned int numRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather final y values kernel.  <a href="#ga01e289bd29d24bfc8e96dd853668900d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
StringSort Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga4caf2158ee71fd9749879baed5b2cb3b">blockWiseStringSort</a> (T *A_keys, T *A_address, T *stringVals, int blockSize, int totalSize, unsigned int stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an initial blockSort based on the size of our partition (limited by shared memory size)  <a href="#ga4caf2158ee71fd9749879baed5b2cb3b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa74a1c4bf04a4c3fbea24f9226ffac02">simpleStringMerge</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int sizePerPartition, int size, int step, int stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two independent sets. Each CUDA block works on two partitions of data without cooperating.  <a href="#gaa74a1c4bf04a4c3fbea24f9226ffac02"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaddfc224cef1f1ea1cd1d9f5d11a0fd18">findMultiPartitions</a> (T *A_keys, T *A_address, T *stringValues, int splitsPP, int numPartitions, int partitionSize, unsigned int *partitionBeginA, unsigned int *partitionSizesA, unsigned int *partitionBeginB, unsigned int *partitionSizesB, size_t size, size_t stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For our multiMerge kernels we need to divide our partitions into smaller partitions. This kernel breaks up a set of partitions into splitsPP*numPartitions subpartitions.  <a href="#gaddfc224cef1f1ea1cd1d9f5d11a0fd18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , int depth&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga6185391aa3d7575c986937e0e938567f">stringMergeMulti</a> (T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int subPartitions, int numBlocks, unsigned int *partitionBeginA, unsigned int *partitionSizeA, unsigned int *partitionBeginB, unsigned int *partitionSizeB, int entirePartitionSize, int step, size_t size, size_t stringSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main merge kernel where multiple CUDA blocks cooperate to merge a partition(s)  <a href="#ga6185391aa3d7575c986937e0e938567f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Tridiagonal functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga7d5ce381d3e5374a8d831bd7ef81c4f6">crpcrKernel</a> (T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int iterations)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid CR-PCR Tridiagonal linear system solver (CRPCR)  <a href="#ga7d5ce381d3e5374a8d831bd7ef81c4f6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Vector Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp63f22eef98a4e7ae7df3cf1d55988889"></a> CUDA kernel methods for basic operations on vectors. </p>
</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga97c40c1ecc9e0fac1dea5e0bc82873f2">vectorAddConstant</a> (T *d_vector, T constant, int n, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant value to all values in the input d_vector.  <a href="#ga97c40c1ecc9e0fac1dea5e0bc82873f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gae01a2f4db216ff09317d622dfece364f">vectorAddUniform</a> (T *d_vector, const T *d_uniforms, int numElements, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to each data element of an array.  <a href="#gae01a2f4db216ff09317d622dfece364f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab9d85a99903057488b0b4e33abed0fc8"></a><!-- doxytag: member="cudpp_kernel::vectorAddUniform2" ref="gab9d85a99903057488b0b4e33abed0fc8" args="(T *g_data, T *uniforms, int n, int eltsPerBlock)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorAddUniform2</b> (T *g_data, T *uniforms, int n, int eltsPerBlock)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , int elementsPerThread, bool fullBlocks&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gadd9d043392f4f45cfb05aee36b63cbe1">vectorAddUniform4</a> (T *d_vector, const T *d_uniforms, int numElements, int vectorRowPitch, int uniformRowPitch, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to each data element of an array (vec4 version)  <a href="#gadd9d043392f4f45cfb05aee36b63cbe1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga0db4319e840ddb75cc7d62847ad29638">vectorAddVector</a> (T *d_vectorA, const T *d_vectorB, int numElements, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds together two vectors.  <a href="#ga0db4319e840ddb75cc7d62847ad29638"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , bool isLastBlockFull&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gabaab0ae2dd48171163c6458416029202">vectorSegmentedAddUniform4</a> (T *d_vector, const T *d_uniforms, const unsigned int *d_maxIndices, unsigned int numElements, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to data elements of an array (vec4 version)  <a href="#gabaab0ae2dd48171163c6458416029202"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , bool isLastBlockFull&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaedce93ab6c42b2bbd3d7985f39cbdd8e">vectorSegmentedAddUniformToRight4</a> (T *d_vector, const T *d_uniforms, const unsigned int *d_minIndices, unsigned int numElements, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to data elements of an array (vec4 version)  <a href="#gaedce93ab6c42b2bbd3d7985f39cbdd8e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The CUDPP Kernel-Level API contains functions that run on the GPU device across a grid of Cooperative Thread Array (CTA, aka Thread Block). These kernels are declared <code>__global__</code> so that they must be invoked from host (CPU) code. They generally invoke GPU <code>__device__</code> routines in the CUDPP <a class="el" href="group__cudpp__cta.html">CTA-Level API</a>. Kernel-Level API functions are used by CUDPP <a class="el" href="group__cudpp__app.html">Application-Level</a> functions to implement their functionality. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga02aca9cfcac6799d445c857626e7d317"></a><!-- doxytag: member="compact_kernel.cuh::compactData" ref="ga02aca9cfcac6799d445c857626e7d317" args="(T *d_out, size_t *d_numValidElements, const unsigned int *d_indices, const unsigned int *d_isValid, const T *d_in, unsigned int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void compactData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consolidate non-null elements - for each non-null element in <em>d_in</em> write it to <em>d_out</em>, in the position specified by <em>d_isValid</em>. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output array of compacted values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>The number of elements in d_in with valid flags set to 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_indices</td><td>Positions where non-null elements will go in d_out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Flags indicating valid (1) and invalid (0) elements. Only valid elements will be copied to <em>d_out</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The length of the <em>d_in</em> in elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga76ac9f96df0a5fc0f9e8c1fb3342224c"></a><!-- doxytag: member="compress_kernel.cuh::bwt_compute_final_kernel" ref="ga76ac9f96df0a5fc0f9e8c1fb3342224c" args="(const uchar *d_bwtIn, const uint *d_values, int *d_bwtIndex, uchar *d_bwtOut, uint numElements, uint tThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void bwt_compute_final_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_bwtIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_bwtOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute final BWT. </p>
<p>This is the final stage in the BWT. This stage computes the final values of the BWT output. It is given the indices of where each of the cyclical rotations of the initial input were sorted to. It uses these indices to figure out the last "column" of the sorted cyclical rotations which is the final BWT output.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_bwtIn</td><td>Input char array to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values</td><td>Input array that gives the indices of where each of the cyclical rotations of the intial input were sorted to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>Output pointer to store the BWT index. The index tells us where the original string sorted to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtOut</td><td>Output char array of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements we are performing a BWT on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>The total threads we have dispatched on the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00ebfa85a812d1939aa6c32364969caf"></a><!-- doxytag: member="compress_kernel.cuh::stringMergeMulti" ref="ga00ebfa85a812d1939aa6c32364969caf" args="(T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int *partitionBeginB, int *partitionSizeB, int entirePartitionSize, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void stringMergeMulti </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multi merge. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>keys after being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>associated values after sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>keys of each of the cyclical rotations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPartitions</td><td>Number of blocks working on a partition (number of sub-partitions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlocks</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginA</td><td>Where each partition/subpartition will begin in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeA</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginB</td><td>Where each partition/subpartition will begin in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeB</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The size of an entire partition (before it is split up) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Size of the enitre array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06344caed45b6f9b8149e1df413dda05"></a><!-- doxytag: member="compress_kernel.cuh::findMultiPartitions" ref="ga06344caed45b6f9b8149e1df413dda05" args="(T *A, int splitsPP, int numPartitions, int partitionSize, int *partitionBeginA, int *partitionSizesA, int *partitionBeginB, int *partitionSizesB, int sizeA)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findMultiPartitions </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitsPP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges the indices for the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Global array of keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitsPP</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPartitions</td><td>number of partitions being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSize</td><td>Size of each partition being considered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginA</td><td>Where each partition/subpartition will begin in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionSizesA</td><td>Size of each partition/subpartition in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginB</td><td>Where each partition/subpartition will begin in B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionSizesB</td><td>Size of each partition/subpartition in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>Size of the entire array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97296735e5a622fef963eeb31f334d60"></a><!-- doxytag: member="compress_kernel.cuh::simpleStringMerge" ref="ga97296735e5a622fef963eeb31f334d60" args="(T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int sizePerPartition, int size, T *stringValues2, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleStringMerge </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simple merge. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>keys after being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>associated values after sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>BWT string manipulated to words </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>Size of each partition being merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of total Array being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues2</td><td>keys of each of the cyclical rotations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements being sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga547123dc3e249d228eaf834e4259b4a9"></a><!-- doxytag: member="compress_kernel.cuh::blockWiseStringSort" ref="ga547123dc3e249d228eaf834e4259b4a9" args="(T *A_keys, T *A_address, const T *stringVals, T *stringVals2, int blockSize, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void blockWiseStringSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringVals2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts blocks of data of size blockSize. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_address</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>BWT string manipulated to words </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals2</td><td>keys of each of the cyclical rotations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>Size of the chunks being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Size of the enitre array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d05a5c631bc48626934620fb72b3b39"></a><!-- doxytag: member="compress_kernel.cuh::bwt_keys_construct_kernel" ref="ga9d05a5c631bc48626934620fb72b3b39" args="(uchar4 *d_bwtIn, uint *d_bwtInRef, uint *d_keys, uint *d_values, uint *d_bwtInRef2, uint tThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void bwt_keys_construct_kernel </td>
          <td>(</td>
          <td class="paramtype">uchar4 *&#160;</td>
          <td class="paramname"><em>d_bwtIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_bwtInRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_bwtInRef2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Massage input to set up for merge sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_bwtIn</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtInRef</td><td>BWT string manipulated to words. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys</td><td>An array of associated keys to sort by the first four chars of the cyclical rotations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values</td><td>Array of values associates with the keys to sort. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtInRef2</td><td>keys of each of the cyclical rotations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>Pointer to the plan object used for this BWT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d72d588b31baf58068a337d13bb603f"></a><!-- doxytag: member="compress_kernel.cuh::mtf_reduction_kernel" ref="ga6d72d588b31baf58068a337d13bb603f" args="(const uchar *d_mtfIn, uchar *d_lists, ushort *d_list_sizes, uint nLists, uint offset, uint numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_reduction_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_mtfIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>First stage in MTF (Reduction) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfIn</td><td>A char array of the input data stream to perform the MTF on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. Initialized to two. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements MTF transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab9ee105a921c3c45a883904eaf1bbd8c"></a><!-- doxytag: member="compress_kernel.cuh::mtf_GLreduction_kernel" ref="gab9ee105a921c3c45a883904eaf1bbd8c" args="(uchar *d_lists, ushort *d_list_sizes, uint offset, uint tThreads, uint nLists)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_GLreduction_kernel </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Second stage in MTF (Global reduction) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. Initialized to two. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>Total number of threads dispatched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga891303a3d2ac4bc37055100434f107d3"></a><!-- doxytag: member="compress_kernel.cuh::mtf_GLdownsweep_kernel" ref="ga891303a3d2ac4bc37055100434f107d3" args="(uchar *d_lists, ushort *d_list_sizes, uint offset, uint lastLevel, uint nLists, uint tThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_GLdownsweep_kernel </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>lastLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Third stage in MTF (Global downsweep) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastLevel</td><td>The limit to which offset can be set to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tThreads</td><td>Total number of threads dispatched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40a79948a407885357d3abca1647fc6f"></a><!-- doxytag: member="compress_kernel.cuh::mtf_localscan_lists_kernel" ref="ga40a79948a407885357d3abca1647fc6f" args="(const uchar *d_mtfIn, uchar *d_mtfOut, uchar *d_lists, ushort *d_list_sizes, uint nLists, uint offset, uint numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mtf_localscan_lists_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_mtfIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_mtfOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort *&#160;</td>
          <td class="paramname"><em>d_list_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute final MTF lists and final MTF output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfIn</td><td>A char array of the input data stream to perform the MTF on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfOut</td><td>A char array of the output with the transformed MTF string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_lists</td><td>A pointer to the start of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_list_sizes</td><td>An array storing the size of each MTF list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLists</td><td>Total number of MTF lists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset during the reduction stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to perform the MTF on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga094c75c96eb9efc8ecf1db4798a9cbc1"></a><!-- doxytag: member="compress_kernel.cuh::huffman_build_histogram_kernel" ref="ga094c75c96eb9efc8ecf1db4798a9cbc1" args="(uint *d_input, uint *d_histograms, uint numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_build_histogram_kernel </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_histograms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute 256-entry histogram. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_input</td><td>An array of words we will use to build our histogram. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histograms</td><td>A pointer where we store our global histograms. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The total number of elements to build our histogram from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7aec2f652e5e46a5e138cc0f47b5e0a"></a><!-- doxytag: member="compress_kernel.cuh::huffman_build_tree_kernel" ref="gac7aec2f652e5e46a5e138cc0f47b5e0a" args="(const uchar *d_input, uchar *d_huffCodesPacked, uint *d_huffCodeLocations, uchar *d_huffCodeLengths, uint *d_histograms, uint *d_histogram, uint *d_nCodesPacked, uint *d_totalEncodedSize, uint histBlocks, uint numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_build_tree_kernel </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>d_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_huffCodesPacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_huffCodeLocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_huffCodeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_histograms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_histogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_nCodesPacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_totalEncodedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>histBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build Huffman tree/codes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_input</td><td>An array of input elements to encode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_huffCodesPacked</td><td>An array of huffman bit codes packed together </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_huffCodeLocations</td><td>An array which stores the starting bit locations of each Huffman bit code </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_huffCodeLengths</td><td>An array which stores the lengths of each Huffman bit code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_histograms</td><td>An input array of histograms to combine </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histogram</td><td>Final histogram combined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_nCodesPacked</td><td>Number of chars it took to store all Huffman bit codes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_totalEncodedSize</td><td>Total number of words it takes to hold the compressed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">histBlocks</td><td>Total number of histograms we will combine into one </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4196de63b3e83a8c85d93e352082c344"></a><!-- doxytag: member="compress_kernel.cuh::huffman_kernel_en" ref="ga4196de63b3e83a8c85d93e352082c344" args="(uchar4 *d_input, uchar *d_codes, uint *d_code_locations, uchar *d_huffCodeLengths, encoded *d_encoded, uint nCodesPacked, uint nThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_kernel_en </td>
          <td>(</td>
          <td class="paramtype">uchar4 *&#160;</td>
          <td class="paramname"><em>d_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_codes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_code_locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>d_huffCodeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">encoded *&#160;</td>
          <td class="paramname"><em>d_encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nCodesPacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform parallel Huffman encoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_input</td><td>Input array to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_codes</td><td>Array of packed Huffman bit codes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_code_locations</td><td>Array of starting Huffman bit locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_huffCodeLengths</td><td>An array storing the bit lengths of the Huffman codes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encoded</td><td>An array of encoded classes which stores the size and data of encoded data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCodesPacked</td><td>Number of chars it took to store all Huffman bit codes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nThreads</td><td>Total number of dispatched threads </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4bda5f1fc2b14ecde1f6e23a87cd0040"></a><!-- doxytag: member="compress_kernel.cuh::huffman_datapack_kernel" ref="ga4bda5f1fc2b14ecde1f6e23a87cd0040" args="(encoded *d_encoded, uint *d_encodedData, uint *d_totalEncodedSize, uint *d_eOffsets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void huffman_datapack_kernel </td>
          <td>(</td>
          <td class="paramtype">encoded *&#160;</td>
          <td class="paramname"><em>d_encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_encodedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_totalEncodedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>d_eOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack together encoded blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_encoded</td><td>An array of encoded objects with stored size and data of the encoded data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encodedData</td><td>An in array to store all encoded data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_totalEncodedSize</td><td>Total number words of the encoded data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_eOffsets</td><td>Array holding the word offsets of each encoded data block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5dc7b9fece113b829667acb1dc96fef"></a><!-- doxytag: member="listrank_kernel.cuh::list_rank_kernel_soa_1" ref="gad5dc7b9fece113b829667acb1dc96fef" args="(T *d_ranked_values, const T *d_unranked_values, const int *d_ping, int *d_pong, int *d_start_indices, int step, int head, int numElts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void list_rank_kernel_soa_1 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>d_ping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_pong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_start_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use pointer jumping to rank values. After ranking the values, calculate the next set of indices. The number of values ranked doubles at each kernel call. Called by <a class="el" href="group__cudpp__app.html#ga0429e4ce1e5ab67980778fdcfc58fb63" title="Launch list ranking.">listRank()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_ping</td><td>Next indices array for the current kernel call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_pong</td><td>Next indices array for the next kernel call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_start_indices</td><td>Holds the starting node indices for "ranking" threads. The number of "ranking" threads doubles at each stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The number of "ranking" threads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head node index of the linked-list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElts</td><td>Number of nodes to rank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91f437989b3d5712b2bf20a124c865ca"></a><!-- doxytag: member="listrank_kernel.cuh::list_rank_kernel_soa_2" ref="ga91f437989b3d5712b2bf20a124c865ca" args="(T *d_ranked_values, const T *d_unranked_values, const int *d_pong, const int *d_start_indices, int head, int numElts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void list_rank_kernel_soa_2 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>d_pong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>d_start_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>After pointer jumping is finished and all threads are able to rank values, ranking continues serially. Each thread ranks values until all values are ranked. Called by <a class="el" href="group__cudpp__app.html#ga0429e4ce1e5ab67980778fdcfc58fb63" title="Launch list ranking.">listRank()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_pong</td><td>Next indices array for the current kernel call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_start_indices</td><td>Holds the starting node indices for "ranking" threads. The number of "ranking" threads doubles at each stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head node index of the linked-list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElts</td><td>Number of nodes to rank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga578c7acbdd21a7c5695cf2b165ec62a6"></a><!-- doxytag: member="mergesort_kernel.cuh::simpleCopy" ref="ga578c7acbdd21a7c5695cf2b165ec62a6" args="(T *A_keys_dev, unsigned int *A_vals_dev, T *A_keys_out_dev, unsigned int *A_vals_out_dev, int offset, int numElementsToCopy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleCopy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_out_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElementsToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies unused portions of arrays in our ping-pong strategy. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys_dev,A_vals_dev</td><td>The keys and values we will be copying </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out_dev,A_vals_out_dev</td><td>The keys and values array we will copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset we are starting to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElementsToCopy</td><td>The number of elements we copy starting from the offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga19022e91ac930fc986e166a8b6b0becb"></a><!-- doxytag: member="mergesort_kernel.cuh::blockWiseSort" ref="ga19022e91ac930fc986e166a8b6b0becb" args="(T *A_keys, unsigned int *A_values, int blockSize, size_t totalSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void blockWiseSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>totalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts blocks of data of size blockSize. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_keys</td><td>keys to be sorted </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_values</td><td>associated values to keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>Size of the chunks being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalSize</td><td>Size of the enitre array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf48872f6f68962fbbd9b7024e4b0729d"></a><!-- doxytag: member="mergesort_kernel.cuh::simpleMerge_lower" ref="gaf48872f6f68962fbbd9b7024e4b0729d" args="(T *A_keys, unsigned int *A_values, T *A_keys_out, unsigned int *A_values_out, int sizePerPartition, int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleMerge_lower </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges the indices for the "lower" block (left block) </p>
<p>Utilizes a "ping-pong" strategy </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>Size of each partition being merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of total Array being sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a079f7c029d053660662d28eb0f2635"></a><!-- doxytag: member="mergesort_kernel.cuh::simpleMerge_higher" ref="ga7a079f7c029d053660662d28eb0f2635" args="(T *A_keys, unsigned int *A_values, T *A_keys_out, unsigned int *A_values_out, int sizePerPartition, int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleMerge_higher </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges the indices for the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_values_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>Size of each partition being merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of total Array being sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9946c915483ccf4a767b621aed653da0"></a><!-- doxytag: member="mergesort_kernel.cuh::findMultiPartitions" ref="ga9946c915483ccf4a767b621aed653da0" args="(T *A, int splitsPP, int numPartitions, int partitionSize, int *partitionBeginA, int *partitionSizesA, int sizeA)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findMultiPartitions </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitsPP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges the indices for the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Global array of keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitsPP</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPartitions</td><td>number of partitions being considered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSize</td><td>Size of each partition being considered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionBeginA</td><td>Where each partition/subpartition will begin in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partitionSizesA</td><td>Size of each partition/subpartition in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>Size of the entire array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga80c66a64b9094db4a280ee4a2bc14ca8"></a><!-- doxytag: member="mergesort_kernel.cuh::mergeMulti_lower" ref="ga80c66a64b9094db4a280ee4a2bc14ca8" args="(T *A_keys_out, unsigned int *A_vals_out, T *A_keys, unsigned int *A_vals, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int entirePartitionSize, int sizeA)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mergeMulti_lower </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks cooperatively Merge two partitions for the indices in the "lower" block (left block) </p>
<p>Utilizes a "ping-pong" strategy </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_vals_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_vals</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPartitions</td><td>Number of blocks working on a partition (number of sub-partitions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlocks</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA</td><td>Partition starting points decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeA</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The size of an entire partition (before it is split up) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>The total size of our array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b9cc399f4dcf17acfa03bb7a078fbe4"></a><!-- doxytag: member="mergesort_kernel.cuh::mergeMulti_higher" ref="ga2b9cc399f4dcf17acfa03bb7a078fbe4" args="(T *A_keys_out, unsigned int *A_vals_out, T *A_keys, unsigned int *A_vals, int subPartitions, int numBlocks, int *partitionBeginA, int *partitionSizeA, int entirePartitionSize, int sizeA)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void mergeMulti_higher </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>A_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks cooperatively Merge two partitions for the indices in the "upper" block (right block) </p>
<p>Utilizes a "ping-pong" strategy </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out</td><td>Resulting array of keys merged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_vals_out</td><td>Resulting array of values merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>Global array of keys to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_vals</td><td>Global array of values to be merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subPartitions</td><td>Number of blocks working on a partition (number of sub-partitions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlocks</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA</td><td>Partition starting points decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionSizeA</td><td>Partition sizes decided by function findMultiPartitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The size of an entire partition (before it is split up) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeA</td><td>The total size of our array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa002e725192c3ac452f6c3168de2895a"></a><!-- doxytag: member="radixsort_kernel.cuh::flipFloats" ref="gaa002e725192c3ac452f6c3168de2895a" args="(uint *values, uint numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void flipFloats </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does special binary arithmetic before sorting floats. </p>
<p>Uses floatFlip function to flip bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Values to be manipulated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numValues</td><td>Number of values to be flipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga359f23566212946fc94d7a61c9e4dfd3"></a><!-- doxytag: member="radixsort_kernel.cuh::unflipFloats" ref="ga359f23566212946fc94d7a61c9e4dfd3" args="(uint *values, uint numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void unflipFloats </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undoes the flips from flipFloats. </p>
<p>Uses floatUnflip function to unflip bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Values to be manipulated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numValues</td><td>Number of values to be unflipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c7394659289d6123e477c7b5b3a9e8b"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortSingleWarp" ref="ga1c7394659289d6123e477c7b5b3a9e8b" args="(uint *keys, uint *values, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortSingleWarp </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimization for sorts of WARP_SIZE or fewer elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4b5a78a353c90d1698b9b7321fa8c9d"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortSingleWarpKeysOnly" ref="gab4b5a78a353c90d1698b9b7321fa8c9d" args="(uint *keys, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortSingleWarpKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimization for sorts of WARP_SIZE or fewer elements. Keys-Only version. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2cf5bfc2844ebb31e5859f7ef28cb975"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortBlocks" ref="ga2cf5bfc2844ebb31e5859f7ef28cb975" args="(uint4 *keysOut, uint4 *valuesOut, uint4 *keysIn, uint4 *valuesIn, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortBlocks </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>valuesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>valuesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements </p>
<p>The radix sort is done in two stages. This stage calls radixSortBlock on each block independently, sorting on the basis of bits (startbit) -&gt; (startbit + nbits)</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "flip" is used to only compile in the float flip code when float keys are used. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keysOut</td><td>Output of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">valuesOut</td><td>Output of associated values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keysIn</td><td>Input of unsorted keys in GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuesIn</td><td>Input of associated input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>The number of blocks of data to sort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98fa842d18a6f9d366c1853ee8458426"></a><!-- doxytag: member="radixsort_kernel.cuh::findRadixOffsets" ref="ga98fa842d18a6f9d366c1853ee8458426" args="(uint2 *keys, uint *counters, uint *blockOffsets, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findRadixOffsets </td>
          <td>(</td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the number of keys of each radix in each block stores offset. </p>
<p>Given an array with blocks sorted according to a 4-bit radix group, each block counts the number of keys that fall into each radix in the group, and finds the starting offset of each radix in the block. It then writes the radix counts to the counters array, and the starting offsets to the blockOffsets array.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Input keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counters</td><td>Radix count for each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">blockOffsets</td><td>The offset address for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga326b66a44772c53ef1657289c511252d"></a><!-- doxytag: member="radixsort_kernel.cuh::reorderData" ref="ga326b66a44772c53ef1657289c511252d" args="(uint *outKeys, uint *outValues, uint2 *keys, uint2 *values, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reorderData </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorders data in the global array. </p>
<p>reorderData shuffles data in the array globally after the radix offsets have been found. On compute version 1.1 and earlier GPUs, this code depends on SORT_CTA_SIZE being 16 * number of radices (i.e. 16 * 2^nbits).</p>
<p>On compute version 1.1 GPUs ("manualCoalesce=true") this function ensures that all writes are coalesced using extra work in the kernel. On later GPUs coalescing rules have been relaxed, so this extra overhead hurts performance. On these GPUs we set manualCoalesce=false and directly store the results.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outKeys</td><td>Output of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>Output of associated values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Input of unsorted keys in GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Input of associated input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffsets</td><td>The offset address for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Address of each radix within each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Number of elements in a block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of data blocks to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Args that are const below should be prototyped as const </dd></dl>

</div>
</div>
<a class="anchor" id="ga5266ebf2bb30d8419cea059b1435d475"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortBlocksKeysOnly" ref="ga5266ebf2bb30d8419cea059b1435d475" args="(uint4 *keysOut, uint4 *keysIn, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortBlocksKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements. </p>
<p>The radix sort is done in two stages. This stage calls radixSortBlock on each block independently, sorting on the basis of bits (startbit) -&gt; (startbit + nbits)</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "flip" is used to only compile in the float flip code when float keys are used. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keysOut</td><td>Output of sorted keys GPU main memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keysIn</td><td>Input of unsorted keys in GPU main memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks to sort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8b6736ae3fa13bb852245f054cbd4eb"></a><!-- doxytag: member="radixsort_kernel.cuh::reorderDataKeysOnly" ref="gac8b6736ae3fa13bb852245f054cbd4eb" args="(uint *outKeys, uint2 *keys, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reorderDataKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorders data in the global array. </p>
<p>reorderDataKeysOnly shuffles data in the array globally after the radix offsets have been found. On compute version 1.1 and earlier GPUs, this code depends on SORT_CTA_SIZE being 16 * number of radices (i.e. 16 * 2^nbits).</p>
<p>On compute version 1.1 GPUs ("manualCoalesce=true") this function ensures that all writes are coalesced using extra work in the kernel. On later GPUs coalescing rules have been relaxed, so this extra overhead hurts performance. On these GPUs we set manualCoalesce=false and directly store the results.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outKeys</td><td>Output result of <a class="el" href="group__cudpp__kernel.html#gac8b6736ae3fa13bb852245f054cbd4eb" title="Reorders data in the global array.">reorderDataKeysOnly()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Keys to be reordered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffsets</td><td>Start offset for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Offset of each radix within each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Number of elements in a block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa69e40f48791d63cdd66d101a22f6a4a"></a><!-- doxytag: member="rand_kernel.cuh::gen_randMD5" ref="gaa69e40f48791d63cdd66d101a22f6a4a" args="(uint4 *d_out, size_t numElements, unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void gen_randMD5 </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main MD5 generation algorithm. </p>
<p>This function runs the MD5 hashing random number generator. It generates MD5 hashes, and uses the output as randomized bits. To repeatedly call this function, always call <a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd" title="Sets the seed used for rand.">cudppRandSeed()</a> first to set a new seed or else the output may be the same due to the deterministic nature of hashes. gen_randMD5 generates 128 random bits per thread. Therefore, the parameter <em>d_out</em> is expected to be an array of type uint4 with <em>numElements</em> indicies.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>the output array of type uint4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>the number of elements in <em>d_out</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>the random seed used to vary the output</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rand__app_8cu.html#aa6aa7195d99a4d1c79c444b95b1d2a92" title="Launches the MD5 Random number generator kernel.">launchRandMD5Kernel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab64eb250a1594485b1b05a3c1458797d"></a><!-- doxytag: member="reduce_kernel.cuh::reduce" ref="gab64eb250a1594485b1b05a3c1458797d" args="(T *odata, const T *idata, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Oper , unsigned int blockSize, bool nIsPow2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reduce </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main reduction kernel. </p>
<p>This reduction kernel adds multiple elements per thread sequentially, and then the threads work together to produce a block sum in shared memory. The code is optimized using warp-synchronous programming to eliminate unnecessary barrier synchronization. Performing sequential work in each thread before performing the log(N) parallel summation reduces the overall cost of the algorithm while keeping the work complexity O(n) and the step complexity O(log n). (Brent's Theorem optimization)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">odata</td><td>The output data pointer. Each block writes a single output element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idata</td><td>The input data pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements to be reduced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga68b0aa93e22b1b3fc622ed8d86bc4310"></a><!-- doxytag: member="scan_kernel.cuh::scan4" ref="ga68b0aa93e22b1b3fc622ed8d86bc4310" args="(T *d_out, const T *d_in, T *d_blockSums, int numElements, unsigned int dataRowPitch, unsigned int blockSumRowPitch)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void scan4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dataRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blockSumRowPitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main scan kernel. </p>
<p>This __global__ device function performs one level of a multiblock scan on an arbitrary-dimensioned array in <em>d_in</em>, returning the result in <em>d_out</em> (which may point to the same array). The same function may be used for single or multi-row scans. To perform a multirow scan, pass the width of each row of the input row (in elements) in <em>dataRowPitch</em>, and the width of the rows of <em>d_blockSums</em> (in elements) in <em>blockSumRowPitch</em>, and invoke with a thread block grid with height greater than 1.</p>
<p>This function peforms one level of a recursive, multiblock scan. At the app level, this function is called by cudppScan and cudppMultiScan and used in combination with <a class="el" href="group__cudpp__kernel.html#gadd9d043392f4f45cfb05aee36b63cbe1" title="Add a uniform value to each data element of an array (vec4 version)">vectorAddUniform4()</a> to produce a complete scan.</p>
<p>Template parameter <em>T</em> is the datatype of the array to be scanned. Template parameter <em>traits</em> is the <a class="el" href="class_scan_traits.html" title="Template class containing compile-time parameters to the scan functions.">ScanTraits</a> struct containing compile-time options for the scan, such as whether it is forward or backward, exclusive or inclusive, multi- or single-row, etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output (scanned) array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>The array of per-block sums </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataRowPitch</td><td>The width of each row of <em>d_in</em> in elements (for multi-row scans) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSumRowPitch</td><td>The with of each row of <em>d_blockSums</em> in elements (for multi-row scans) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2412fe9c8c1029cadc0d191ccad222f"></a><!-- doxytag: member="segmented_scan_kernel.cuh::segmentedScan4" ref="gaf2412fe9c8c1029cadc0d191ccad222f" args="(T *d_odata, const T *d_idata, const unsigned int *d_iflags, unsigned int numElements, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void segmentedScan4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main segmented scan kernel. </p>
<p>This __global__ device function performs one level of a multiblock segmented scan on an one-dimensioned array in <em>d_idata</em>, returning the result in <em>d_odata</em> (which may point to the same array).</p>
<p>This function performs one level of a recursive, multiblock scan. At the app level, this function is called by cudppSegmentedScan and used in combination with either <a class="el" href="group__cudpp__kernel.html#gabaab0ae2dd48171163c6458416029202" title="Add a uniform value to data elements of an array (vec4 version)">vectorSegmentedAddUniform4()</a> (forward) or <a class="el" href="group__cudpp__kernel.html#gaedce93ab6c42b2bbd3d7985f39cbdd8e" title="Add a uniform value to data elements of an array (vec4 version)">vectorSegmentedAddUniformToRight4()</a> (backward) to produce a complete segmented scan.</p>
<p>Template parameter <em>T</em> is the datatype of the array to be scanned. Template parameter <em>traits</em> is the <a class="el" href="class_segmented_scan_traits.html" title="Template class containing compile-time parameters to the segmented scan functions.">SegmentedScanTraits</a> struct containing compile-time options for the segmented scan, such as whether it is forward or backward, inclusive or exclusive, etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_odata</td><td>The output (scanned) array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>The input array of flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>The array of per-block sums </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockFlags</td><td>The array of per-block OR-reduction of flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockIndices</td><td>The array of per-block min-reduction of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc255d86178e5e591c3f2d2e8d5f564b"></a><!-- doxytag: member="spmvmult_kernel.cuh::sparseMatrixVectorFetchAndMultiply" ref="gadc255d86178e5e591c3f2d2e8d5f564b" args="(unsigned int *d_flags, T *d_prod, const T *d_A, const T *d_x, const unsigned int *d_indx, unsigned int numNZElts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isFullBlock&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sparseMatrixVectorFetchAndMultiply </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numNZElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch and multiply kernel. </p>
<p>This __global__ device function takes an element from the vector d_A, finds its column in d_indx and multiplies the element from d_A with its corresponding (that is having the same row) element in d_x and stores the resulting product in d_prod. It also sets all the elements of d_flags to 0.</p>
<p>Template parameter <em>T</em> is the datatype of the matrix A and x.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flags</td><td>The output flags array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_prod</td><td>The output products array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_A</td><td>The input matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>The input array x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_indx</td><td>The input array of column indices for each element in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNZElts</td><td>The number of non-zero elements in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga650782aef0e14c36782f5c24cd96a8dd"></a><!-- doxytag: member="spmvmult_kernel.cuh::sparseMatrixVectorSetFlags" ref="ga650782aef0e14c36782f5c24cd96a8dd" args="(unsigned int *d_flags, const unsigned int *d_rowindx, unsigned int numRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sparseMatrixVectorSetFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_rowindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Flags kernel. </p>
<p>This __global__ device function takes an element from the vector d_rowindx, and sets the corresponding position in d_flags to 1</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flags</td><td>The output flags array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_rowindx</td><td>The starting index of each row in the "flattened" version of matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01e289bd29d24bfc8e96dd853668900d"></a><!-- doxytag: member="spmvmult_kernel.cuh::yGather" ref="ga01e289bd29d24bfc8e96dd853668900d" args="(T *d_y, const T *d_prod, const unsigned int *d_rowFindx, unsigned int numRows)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void yGather </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_rowFindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gather final y values kernel. </p>
<p>This __global__ device function takes an element from the vector d_rowFindx, which for each row gives the index of the last element of that row, reads the corresponding position in d_prod and write it in d_y</p>
<p>Template parameter <em>T</em> is the datatype of the matrix A and x.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_y</td><td>The output result array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_prod</td><td>The input products array (which now contains sums for each row) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_rowFindx</td><td>The starting index of each row in the "flattened" version of matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4caf2158ee71fd9749879baed5b2cb3b"></a><!-- doxytag: member="stringsort_kernel.cuh::blockWiseStringSort" ref="ga4caf2158ee71fd9749879baed5b2cb3b" args="(T *A_keys, T *A_address, T *stringVals, int blockSize, int totalSize, unsigned int stringSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void blockWiseStringSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>totalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does an initial blockSort based on the size of our partition (limited by shared memory size) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A_keys,A_address</td><td>This sort is in-place. A_keys and A_address store the key (first four characters) and addresses of our strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>Global array of strings for tie breaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>size of each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalSize</td><td>The total size of the array we are sorting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>The size of our string array (stringVals) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa74a1c4bf04a4c3fbea24f9226ffac02"></a><!-- doxytag: member="stringsort_kernel.cuh::simpleStringMerge" ref="gaa74a1c4bf04a4c3fbea24f9226ffac02" args="(T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int sizePerPartition, int size, int step, int stringSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void simpleStringMerge </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizePerPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two independent sets. Each CUDA block works on two partitions of data without cooperating. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys</td><td>First four characters (input) of our sets to merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_values</td><td>Addresses of the strings (for tie breaks) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>Global string array for tie breaks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out,A_values_out</td><td>Keys and values array after merge step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizePerPartition</td><td>The size of each partition for this merge step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Global size of our array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>Number of merges done so far </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>global string length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaddfc224cef1f1ea1cd1d9f5d11a0fd18"></a><!-- doxytag: member="stringsort_kernel.cuh::findMultiPartitions" ref="gaddfc224cef1f1ea1cd1d9f5d11a0fd18" args="(T *A_keys, T *A_address, T *stringValues, int splitsPP, int numPartitions, int partitionSize, unsigned int *partitionBeginA, unsigned int *partitionSizesA, unsigned int *partitionBeginB, unsigned int *partitionSizesB, size_t size, size_t stringSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findMultiPartitions </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitsPP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For our multiMerge kernels we need to divide our partitions into smaller partitions. This kernel breaks up a set of partitions into splitsPP*numPartitions subpartitions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys,A_address</td><td>First four characters (input), and addresses of our inputs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>Global string array for tie breaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitsPP,numPartitions,partitionSize</td><td>Partition information for this routine (splitsPP=splits Per Partition) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA,partitionSizesA</td><td>Partition starting points and sizes for each new subpartition in our original set in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginB,partitionSizesB</td><td>Partition starting points and sizes for each new subpartition in our original set in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size,stringSize</td><td>Number of elements in our set, and size of our global string array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6185391aa3d7575c986937e0e938567f"></a><!-- doxytag: member="stringsort_kernel.cuh::stringMergeMulti" ref="ga6185391aa3d7575c986937e0e938567f" args="(T *A_keys, T *A_keys_out, T *A_values, T *A_values_out, T *stringValues, int subPartitions, int numBlocks, unsigned int *partitionBeginA, unsigned int *partitionSizeA, unsigned int *partitionBeginB, unsigned int *partitionSizeB, int entirePartitionSize, int step, size_t size, size_t stringSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int depth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void stringMergeMulti </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>stringValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionBeginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>partitionSizeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entirePartitionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main merge kernel where multiple CUDA blocks cooperate to merge a partition(s) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_keys,A_values</td><td>First four characters (input), and addresses of our inputs </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_keys_out,A_values_out</td><td>First four characters, and addresses for our outputs(ping-pong) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringValues</td><td>string array for tie breaks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subPartitions,numBlocks</td><td>Number of splits per partitions and number of partitions respectively </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginA,partitionSizeA</td><td>Where partitions begin and how large they are for Segment A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partitionBeginB,partitionSizeB</td><td>Where partitions begin and how large they are for Segment B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entirePartitionSize</td><td>The maximum length of a partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>Number of merge cycles done </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of total strings being sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>Length of string array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7d5ce381d3e5374a8d831bd7ef81c4f6"></a><!-- doxytag: member="tridiagonal_kernel.cuh::crpcrKernel" ref="ga7d5ce381d3e5374a8d831bd7ef81c4f6" args="(T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int iterations)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void crpcrKernel </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>systemSizeOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hybrid CR-PCR Tridiagonal linear system solver (CRPCR) </p>
<p>This kernel solves a tridiagonal linear system using a hybrid CR-PCR algorithm. The solver first reduces the system size using cyclic reduction, then solves the intermediate system using parallel cyclic reduction to reduce shared memory bank conflicts and algorithmic steps, and finally switches back to cyclic reduction to solve all unknowns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSizeOriginal</td><td>The size of each system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>The computed number of PCR iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97c40c1ecc9e0fac1dea5e0bc82873f2"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddConstant" ref="ga97c40c1ecc9e0fac1dea5e0bc82873f2" args="(T *d_vector, T constant, int n, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddConstant </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a constant value to all values in the input d_vector. </p>
<p>Each thread adds two pairs of elements. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Test this function -- it is currently not yet used.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_vector</td><td>The array of elements to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant</td><td>The constant value to be added to elements of <em>d_vector</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in the d_vector to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>An optional offset to the beginning of the elements in the input array to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae01a2f4db216ff09317d622dfece364f"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddUniform" ref="gae01a2f4db216ff09317d622dfece364f" args="(T *d_vector, const T *d_uniforms, int numElements, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddUniform </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to each data element of an array. </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to all values "owned" by the CTA in <em>d_vector</em>. Each thread adds two pairs of values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd9d043392f4f45cfb05aee36b63cbe1"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddUniform4" ref="gadd9d043392f4f45cfb05aee36b63cbe1" args="(T *d_vector, const T *d_uniforms, int numElements, int vectorRowPitch, int uniformRowPitch, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , int elementsPerThread, bool fullBlocks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddUniform4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectorRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uniformRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to each data element of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to all values "owned" by the CTA in <em>d_vector</em>. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vectorRowPitch</td><td>For 2D arrays, the pitch (in elements) of the rows of <em>d_vector</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniformRowPitch</td><td>For 2D arrays, the pitch (in elements) of the rows of <em>d_uniforms</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0db4319e840ddb75cc7d62847ad29638"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddVector" ref="ga0db4319e840ddb75cc7d62847ad29638" args="(T *d_vectorA, const T *d_vectorB, int numElements, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddVector </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vectorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_vectorB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds together two vectors. </p>
<p>Each thread adds two pairs of elements. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Test this function -- it is currently not yet used.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vectorA</td><td>The left operand array and the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_vectorB</td><td>The right operand array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the vectors to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>An optional offset to the beginning of the elements in the input arrays to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaab0ae2dd48171163c6458416029202"></a><!-- doxytag: member="vector_kernel.cuh::vectorSegmentedAddUniform4" ref="gabaab0ae2dd48171163c6458416029202" args="(T *d_vector, const T *d_uniforms, const unsigned int *d_maxIndices, unsigned int numElements, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , bool isLastBlockFull&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorSegmentedAddUniform4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_maxIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to data elements of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to values "owned" by the CTA in <em>d_vector</em>. The uniform value is added to only those values "owned" by the CTA which have an index less than d_maxIndex. If d_maxIndex for that CTA is UINT_MAX it adds the uniform to all values "owned" by the CTA. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_maxIndices</td><td>The array of maximum indices (one per CTA). This is index upto which the uniform would be added. If this is UINT_MAX the uniform is added to all elements of the CTA. This index is 1-based. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaedce93ab6c42b2bbd3d7985f39cbdd8e"></a><!-- doxytag: member="vector_kernel.cuh::vectorSegmentedAddUniformToRight4" ref="gaedce93ab6c42b2bbd3d7985f39cbdd8e" args="(T *d_vector, const T *d_uniforms, const unsigned int *d_minIndices, unsigned int numElements, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , bool isLastBlockFull&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorSegmentedAddUniformToRight4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_minIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to data elements of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to values "owned" by the CTA in <em>d_vector</em>. The uniform value is added to only those values "owned" by the CTA which have an index greater than d_minIndex. If d_minIndex for that CTA is 0 it adds the uniform to all values "owned" by the CTA. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_minIndices</td><td>The array of minimum indices (one per CTA). The uniform is added to the right of this index (that is, to every index that is greater than this index). If this is 0, the uniform is added to all elements of the CTA. This index is 1-based to prevent overloading of what 0 means. In our case it means absence of a flag. But if the first element of a CTA has flag the index will also be 0. Hence we use 1-based indices so the index is 1 in the latter case. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Mar 8 2013 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
