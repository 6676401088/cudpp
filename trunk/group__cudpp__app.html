<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Application-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">2.0</span></div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">CUDPP Application-Level API</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cuda_h_t_1_1_cuckoo_hashing_1_1_hash_table.html">CudaHT::CuckooHashing::HashTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic hash table that stores one value for each key.  <a href="class_cuda_h_t_1_1_cuckoo_hashing_1_1_hash_table.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__hash__data__structures.html">Hash Table Data Structures and Constants</a></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga040dfdfedb09338ecbb6c154ce164717">calculateCompactLaunchParams</a> (const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.  <a href="#ga040dfdfedb09338ecbb6c154ce164717"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40">compactArray</a> (T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the non-zero elements of an array.  <a href="#ga00003db78fb8a269263a5e1205257f40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21">allocCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#gae84f008f74af507fb9da9568ee22bd21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5f6b8e696bb6ec4d87d55046041dfb9e">freeCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf">cudppCompactDispatch</a> (void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch compactArray for the specified datatype.  <a href="#gafccd7f148a985a1ec19b30cf1d00fdbf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Compress Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga61b0eeace5a27886e28282faa9bded32">huffmanEncoding</a> (unsigned int *d_hist, unsigned int *d_encodeOffset, unsigned int *d_compressedSize, unsigned int *d_compressed, size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Huffman encoding.  <a href="#ga61b0eeace5a27886e28282faa9bded32"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae12e2054e77890215885b90c8ae65ac7">moveToFrontTransform</a> (unsigned char *d_mtfIn, unsigned char *d_mtfOut, size_t numElements, const T *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the Move-to-Front Transform (MTF)  <a href="#gae12e2054e77890215885b90c8ae65ac7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga445ca03c1d2b3ce2ba035fcac5d106b9">burrowsWheelerTransform</a> (unsigned char *d_uncompressed, int *d_bwtIndex, unsigned char *d_bwtOut, size_t numElements, const T *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the Burrows-Wheeler Transform (BWT)  <a href="#ga445ca03c1d2b3ce2ba035fcac5d106b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga1f998ac3907d8e374be63abb26584372">burrowsWheelerTransformWrapper</a> (unsigned char *d_in, int *d_bwtIndex, size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Burrows-Wheeler Transform (BWT).  <a href="#ga1f998ac3907d8e374be63abb26584372"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga8c20cb730679c44440eb3681d68c2668">burrowsWheelerTransformWrapper</a> (unsigned char *d_in, int *d_bwtIndex, unsigned char *d_bwtOut, size_t numElements, const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Burrows-Wheeler Transform (BWT).  <a href="#ga8c20cb730679c44440eb3681d68c2668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga4916d0d00fb75590b75d4c4d8a7acf51">moveToFrontTransformWrapper</a> (size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Move-to-Front (MTF) transform.  <a href="#ga4916d0d00fb75590b75d4c4d8a7acf51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga6798eb8443a725818dab4c06b33f067e">moveToFrontTransformWrapper</a> (unsigned char *d_in, unsigned char *d_mtfOut, size_t numElements, const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calling the Move-to-Front (MTF) transform.  <a href="#ga6798eb8443a725818dab4c06b33f067e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga6e3305c8f69237c1ba7c859e4c1c8532">allocBwtStorage</a> (<a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by BWT.  <a href="#ga6e3305c8f69237c1ba7c859e4c1c8532"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaebe506539a6a0c0211ec5b5704a825b0">allocMtfStorage</a> (<a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by MTF.  <a href="#gaebe506539a6a0c0211ec5b5704a825b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga0e78a1777b62c4ed99d57998b6216bf6">allocCompressStorage</a> (CUDPPCompressPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by compression.  <a href="#ga0e78a1777b62c4ed99d57998b6216bf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga2b34f7f6c5234a8b9c9a021bac8d6f15">freeCompressStorage</a> (CUDPPCompressPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a CUDPPCompressPlan object.  <a href="#ga2b34f7f6c5234a8b9c9a021bac8d6f15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga2f0a7bff9b659cab266bb73538ce6521">freeBwtStorage</a> (<a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT.">CUDPPBwtPlan</a> object.  <a href="#ga2f0a7bff9b659cab266bb73538ce6521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaaa0d04a5e136c191db6d4089006ebeec">freeMtfStorage</a> (<a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF.">CUDPPMtfPlan</a> object.  <a href="#gaaa0d04a5e136c191db6d4089006ebeec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gad14e0a21423bd754bd31d2cedf0cd6c3">cudppCompressDispatch</a> (void *d_uncompressed, void *d_bwtIndex, void *d_histSize, void *d_hist, void *d_encodeOffset, void *d_compressedSize, void *d_compressed, size_t numElements, const CUDPPCompressPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform parallel compression on an array with the specified configuration.  <a href="#gad14e0a21423bd754bd31d2cedf0cd6c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga3e68297787efbb92efe2c1fb1cb6def9">cudppBwtDispatch</a> (void *d_bwtIn, void *d_bwtOut, void *d_bwtIndex, size_t numElements, const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform the Burrows-Wheeler transform.  <a href="#ga3e68297787efbb92efe2c1fb1cb6def9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gacb94a70fa336d25ddef1ce3833b53258">cudppMtfDispatch</a> (void *d_mtfIn, void *d_mtfOut, size_t numElements, const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform the Move-to-Front transform.  <a href="#gacb94a70fa336d25ddef1ce3833b53258"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
ListRank Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga0429e4ce1e5ab67980778fdcfc58fb63">listRank</a> (T *d_ranked_values, T *d_unranked_values, int *d_next_indices, size_t head, size_t numElements, const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch list ranking.  <a href="#ga0429e4ce1e5ab67980778fdcfc58fb63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga355d6255be4206b598445d017489fbab">allocListRankStorage</a> (<a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by ListRank.  <a href="#ga355d6255be4206b598445d017489fbab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gacbe7bfb2886d9a37ec07836e385635d5">freeListRankStorage</a> (<a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank.">CUDPPListRankPlan</a> object.  <a href="#gacbe7bfb2886d9a37ec07836e385635d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaf384cd261f362eef6a000dc5b15aa53e">cudppListRankDispatch</a> (void *d_ranked_values, void *d_unranked_values, void *d_next_indices, size_t head, size_t numElements, const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform parallel list ranking on a linked-list with the specified configuration.  <a href="#gaf384cd261f362eef6a000dc5b15aa53e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
MergeSort Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga79f316efe7af5ccb04524701458ce9d8">runMergeSort</a> (T *pkeys, unsigned int *pvals, size_t numElements, const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs merge sor utilzing three stages. (1) Blocksort, (2) simple merge and (3) multi merge.  <a href="#ga79f316efe7af5ccb04524701458ce9d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gad1ad99cc80465972cf1fb732b81ab8e6">allocMergeSortStorage</a> (<a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gad1ad99cc80465972cf1fb732b81ab8e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga290ef022e420d9721f8cb15d1475c074">freeMergeSortStorage</a> (<a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocRadixSortStorage.  <a href="#ga290ef022e420d9721f8cb15d1475c074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga1cefde64490a053ec2453c0a7897840e">cudppMergeSortDispatch</a> (void *keys, void *values, size_t numElements, const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#ga1cefde64490a053ec2453c0a7897840e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67cf5220afab3f55dde96a0ee40ace3e"></a><!-- doxytag: member="cudpp_app::BLOCKSORT_SIZE" ref="ga67cf5220afab3f55dde96a0ee40ace3e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKSORT_SIZE</b>&#160;&#160;&#160;1024</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaa6043ddac717a99c471bb3dc0fc3c0de">allocRadixSortStorage</a> (<a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gaa6043ddac717a99c471bb3dc0fc3c0de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5b103658becc8dbb8c5ca1026ff61598">freeRadixSortStorage</a> (<a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocRadixSortStorage.  <a href="#ga5b103658becc8dbb8c5ca1026ff61598"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga40828c556804c4367dfae5527b874e9b"></a><!-- doxytag: member="cudpp_app::runSort" ref="ga40828c556804c4367dfae5527b874e9b" args="(T *pkeys, unsigned int *pvals, size_t numElements, const CUDPPRadixSortPlan *plan)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>runSort</b> (T *pkeys, unsigned int *pvals, size_t numElements, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga75c1c0e157a23d4747fc2ae94570aab0">cudppRadixSortDispatch</a> (void *keys, void *values, size_t numElements, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#ga75c1c0e157a23d4747fc2ae94570aab0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9">scanArrayRecursive</a> (T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform recursive scan on arbitrary size arrays.  <a href="#gaab8062495149d43064e1f03b4a8f15f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6">allocScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by scan.  <a href="#ga344e15dee4b3b2351c40bd9cc732bed6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga399f5095b183ad026687fd227802ba5c">freeScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object.  <a href="#ga399f5095b183ad026687fd227802ba5c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaac1d3477c349371d25fe4f4df0007ffc"></a><!-- doxytag: member="cudpp_app::cudppScanDispatchOperator" ref="gaac1d3477c349371d25fe4f4df0007ffc" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
template&lt;typename T , bool isBackward, bool isExclusive&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchOperator</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga50b953ee85f7bad7aec405447de288af"></a><!-- doxytag: member="cudpp_app::cudppScanDispatchType" ref="ga50b953ee85f7bad7aec405447de288af" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
template&lt;bool isBackward, bool isExclusive&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchType</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d">cudppScanDispatch</a> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.  <a href="#ga49485cb95e21695293a9c35f8355336d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
StringSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga9efaeeadb705b5709cd2ff27bfc0bab3">runStringSort</a> (unsigned int *pkeys, unsigned int *pvals, unsigned int *stringVals, size_t numElements, size_t stringArrayLength, const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs merge sor utilzing three stages. (1) Blocksort, (2) simple merge and (3) multi merge on a set of strings.  <a href="#ga9efaeeadb705b5709cd2ff27bfc0bab3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gabe53de69a1cdb089b31247af9d0211a2">allocStringSortStorage</a> (<a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gabe53de69a1cdb089b31247af9d0211a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga9270888514859ed9d40a3fc310521cbd">freeStringSortStorage</a> (<a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocStringSortStorage.  <a href="#ga9270888514859ed9d40a3fc310521cbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga607a4608ed36a84e4d35c9c75aa6297a">cudppStringSortDispatch</a> (void *keys, void *values, void *stringVals, size_t numElements, size_t stringArrayLength, const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#ga607a4608ed36a84e4d35c9c75aa6297a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67cf5220afab3f55dde96a0ee40ace3e"></a><!-- doxytag: member="cudpp_app::BLOCKSORT_SIZE" ref="ga67cf5220afab3f55dde96a0ee40ace3e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BLOCKSORT_SIZE</b>&#160;&#160;&#160;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50267d552ca6f788254032e40046b770"></a><!-- doxytag: member="cudpp_app::DEPTH" ref="ga50267d552ca6f788254032e40046b770" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH</b>&#160;&#160;&#160;8</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Tridiagonal functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2d0300574dee733d44099058671e1267"></a><!-- doxytag: member="cudpp_app::crpcrSharedSize" ref="ga2d0300574dee733d44099058671e1267" args="(unsigned int systemSizeOriginal)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crpcrSharedSize</b> (unsigned int systemSizeOriginal)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga98079b338b2af21016a5cba9e00a0eb6">crpcr</a> (T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int numSystems)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid CR-PCR solver (CRPCR)  <a href="#ga98079b338b2af21016a5cba9e00a0eb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga0509ed92fe9640a9d7ea1ce9cfa639d3">cudppTridiagonalDispatch</a> (void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems, const <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html">CUDPPTridiagonalPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the tridiagonal function based on the plan.  <a href="#ga0509ed92fe9640a9d7ea1ce9cfa639d3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The CUDPP Application-Level API contains functions that run on the host CPU and invoke GPU routines in the CUDPP <a class="el" href="group__cudpp__kernel.html">Kernel-Level API</a>. Application-Level API functions are used by CUDPP <a class="el" href="group__public_interface.html">Public Interface</a> functions to implement CUDPP's core functionality. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga040dfdfedb09338ecbb6c154ce164717"></a><!-- doxytag: member="compact_app.cu::calculateCompactLaunchParams" ref="ga040dfdfedb09338ecbb6c154ce164717" args="(const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculateCompactLaunchParams </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numEltsPerBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>. </p>
<p>Calculates the block size and number of blocks from the total number of elements and the maximum threads per block. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.</p>
<p>The calculation is pretty straightforward - the number of blocks is calculated by dividing the number of input elements by the product of the number of threads in each CTA and the number of elements each thread will process. numThreads and numEltsPerBlock are also simple to calculate. Please note that in cases where numElements is not an exact multiple of SCAN_ELTS_PER_THREAD * CTA_SIZE we would have threads which do nothing or have a thread which will process less than SCAN_ELTS_PER_THREAD elements.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numThreads</td><td>Number of threads in each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numEltsPerBlock</td><td>Number of elements processed per block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00003db78fb8a269263a5e1205257f40"></a><!-- doxytag: member="compact_app.cu::compactArray" ref="ga00003db78fb8a269263a5e1205257f40" args="(T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compactArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compact the non-zero elements of an array. </p>
<p>Given an input array <em>d_in</em>, <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> outputs a compacted version which does not have null (zero) elements. Also ouputs the number of non-zero elements in the compacted array. Called by <a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf" title="Dispatch compactArray for the specified datatype.">cudppCompactDispatch()</a>.</p>
<p>The algorithm is straightforward, involving two steps (most of the complexity is hidden in scan, invoked with <a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d" title="Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.">cudppScanDispatch()</a> ).</p>
<ol type="1">
<li>scanArray() performs a prefix sum on <em>d_isValid</em> to compute output indices.</li>
<li><a class="el" href="group__cudpp__kernel.html#ga02aca9cfcac6799d445c857626e7d317" title="Consolidate non-null elements - for each non-null element in d_in write it to d_out, in the position specified by d_isValid. Called by compactArray().">compactData()</a> takes <em>d_in</em> and an intermediate array of output indices as input and writes the values with valid flags in <em>d_isValid</em> into <em>d_out</em> using the output indices.</li>
</ol>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Array of compacted non-null elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to unsigned int to store number of non-null elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_isValid</td><td>Array of flags, 1 for each non-null element, 0 for each null element. Same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae84f008f74af507fb9da9568ee22bd21"></a><!-- doxytag: member="compact_app.cu::allocCompactStorage" ref="gae84f008f74af507fb9da9568ee22bd21" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>In addition to the internal <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> contained in <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a>, CUDPPCompact also needs a temporary device array of output indices, which is allocated by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><!-- doxytag: member="compact_app.cu::freeCompactStorage" ref="ga5f6b8e696bb6ec4d87d55046041dfb9e" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>Deallocates the output indices array allocated by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafccd7f148a985a1ec19b30cf1d00fdbf"></a><!-- doxytag: member="compact_app.cu::cudppCompactDispatch" ref="gafccd7f148a985a1ec19b30cf1d00fdbf" args="(void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppCompactDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch compactArray for the specified datatype. </p>
<p>A thin wrapper on top of compactArray which calls <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> for the data type specified in <em>config</em>. This is the app-level interface to compact used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Compacted array of non-zero elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to an unsigned int to store the number of non-zero elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Array of boolean valid flags with same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to plan object for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61b0eeace5a27886e28282faa9bded32"></a><!-- doxytag: member="compress_app.cu::huffmanEncoding" ref="ga61b0eeace5a27886e28282faa9bded32" args="(unsigned int *d_hist, unsigned int *d_encodeOffset, unsigned int *d_compressedSize, unsigned int *d_compressed, size_t numElements, const CUDPPCompressPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void huffmanEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_encodeOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_compressedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform Huffman encoding. </p>
<p>Performs Huffman encoding on the input data stream. The input data stream is the output data stream from the previous stage (MTF) in our compress stream.</p>
<p>The input is given by the output of the Move-to-Front transform (MTF). There are a few things that need to be store along with the compressed data. We also store the word offset of the compressed data stream because our data is compressed into indepedent blocks (word granularity) so that they can be encoded and decoded in parallel. The number of independent blocks is HUFF_THREADS_PER_BLOCK*HUFF_WORK_PER_THREAD.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_hist</td><td>Histogram array of the input data stream used for decoding. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encodeOffset</td><td>An array of the word offsets of the independent compressed data blocks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressedSize</td><td>Pointer to the total size in words of all compressed data blocks combined. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressed</td><td>A pointer to the compressed data blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to compress. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae12e2054e77890215885b90c8ae65ac7"></a><!-- doxytag: member="compress_app.cu::moveToFrontTransform" ref="gae12e2054e77890215885b90c8ae65ac7" args="(unsigned char *d_mtfIn, unsigned char *d_mtfOut, size_t numElements, const T *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void moveToFrontTransform </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_mtfIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_mtfOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform the Move-to-Front Transform (MTF) </p>
<p>Performs a Move-to-Front (MTF) transform on the input data stream. The MTF transform is the second stage in our compress pipeline. The MTF manipulates the input data stream to improve the performance of entropy encoding.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfIn</td><td>An array of the input data stream to perform the MTF transform on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_mtfOut</td><td>An array to store the output of the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements of the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this MTF transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga445ca03c1d2b3ce2ba035fcac5d106b9"></a><!-- doxytag: member="compress_app.cu::burrowsWheelerTransform" ref="ga445ca03c1d2b3ce2ba035fcac5d106b9" args="(unsigned char *d_uncompressed, int *d_bwtIndex, unsigned char *d_bwtOut, size_t numElements, const T *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void burrowsWheelerTransform </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_uncompressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_bwtOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform the Burrows-Wheeler Transform (BWT) </p>
<p>Performs the Burrows-Wheeler Transform (BWT) on a given character string. The BWT is an algorithm which is commonly used in compression applications, mainly bzip2. The BWT orders the characters in such a way that the output tends to have many long runs of repeated characters. This bodes well for later stages in compression pipelines which perform better with repeated characters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uncompressed</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>The index at which the original string in the BWT sorts to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtOut</td><td>An array to store the output of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this BWT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f998ac3907d8e374be63abb26584372"></a><!-- doxytag: member="compress_app.cu::burrowsWheelerTransformWrapper" ref="ga1f998ac3907d8e374be63abb26584372" args="(unsigned char *d_in, int *d_bwtIndex, size_t numElements, const CUDPPCompressPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void burrowsWheelerTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for calling the Burrows-Wheeler Transform (BWT). </p>
<p>This is a wrapper function for calling the BWT. This wrapper is used internally via the compress application to call <a class="el" href="group__cudpp__app.html#ga445ca03c1d2b3ce2ba035fcac5d106b9" title="Perform the Burrows-Wheeler Transform (BWT)">burrowsWheelerTransform()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>The index at which the original string in the BWT sorts to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the compress stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c20cb730679c44440eb3681d68c2668"></a><!-- doxytag: member="compress_app.cu::burrowsWheelerTransformWrapper" ref="ga8c20cb730679c44440eb3681d68c2668" args="(unsigned char *d_in, int *d_bwtIndex, unsigned char *d_bwtOut, size_t numElements, const CUDPPBwtPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void burrowsWheelerTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_bwtOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for calling the Burrows-Wheeler Transform (BWT). </p>
<p>This is a wrapper function for calling the BWT. This wrapper is used internally via the BWT primitive to call <a class="el" href="group__cudpp__app.html#ga445ca03c1d2b3ce2ba035fcac5d106b9" title="Perform the Burrows-Wheeler Transform (BWT)">burrowsWheelerTransform()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>A char array of the input data stream to perform the BWT on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>The index at which the original string in the BWT sorts to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtOut</td><td>An array to store the output of the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the BWT. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this BWT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4916d0d00fb75590b75d4c4d8a7acf51"></a><!-- doxytag: member="compress_app.cu::moveToFrontTransformWrapper" ref="ga4916d0d00fb75590b75d4c4d8a7acf51" args="(size_t numElements, const CUDPPCompressPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveToFrontTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for calling the Move-to-Front (MTF) transform. </p>
<p>This is a wrapper function for calling the MTF. This wrapper is used internally via the compress application to call <a class="el" href="group__cudpp__app.html#gae12e2054e77890215885b90c8ae65ac7" title="Perform the Move-to-Front Transform (MTF)">moveToFrontTransform()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6798eb8443a725818dab4c06b33f067e"></a><!-- doxytag: member="compress_app.cu::moveToFrontTransformWrapper" ref="ga6798eb8443a725818dab4c06b33f067e" args="(unsigned char *d_in, unsigned char *d_mtfOut, size_t numElements, const CUDPPMtfPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveToFrontTransformWrapper </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>d_mtfOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for calling the Move-to-Front (MTF) transform. </p>
<p>This is a wrapper function for calling the MTF. This wrapper is used internally via the MTF primitive to call <a class="el" href="group__cudpp__app.html#gae12e2054e77890215885b90c8ae65ac7" title="Perform the Move-to-Front Transform (MTF)">moveToFrontTransform()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>An input char array to perform the MTF on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfOut</td><td>An output char array to store the MTF transformed stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of input elements to the MTF transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this MTF. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e3305c8f69237c1ba7c859e4c1c8532"></a><!-- doxytag: member="compress_app.cu::allocBwtStorage" ref="ga6e3305c8f69237c1ba7c859e4c1c8532" args="(CUDPPBwtPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocBwtStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by BWT. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT.">CUDPPBwtPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebe506539a6a0c0211ec5b5704a825b0"></a><!-- doxytag: member="compress_app.cu::allocMtfStorage" ref="gaebe506539a6a0c0211ec5b5704a825b0" args="(CUDPPMtfPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocMtfStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by MTF. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF.">CUDPPMtfPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e78a1777b62c4ed99d57998b6216bf6"></a><!-- doxytag: member="compress_app.cu::allocCompressStorage" ref="ga0e78a1777b62c4ed99d57998b6216bf6" args="(CUDPPCompressPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocCompressStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by compression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to CUDPPCompressPlan object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b34f7f6c5234a8b9c9a021bac8d6f15"></a><!-- doxytag: member="compress_app.cu::freeCompressStorage" ref="ga2b34f7f6c5234a8b9c9a021bac8d6f15" args="(CUDPPCompressPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeCompressStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block arrays in a CUDPPCompressPlan object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to CUDPPCompressPlan object initialized by <a class="el" href="group__cudpp__app.html#ga0e78a1777b62c4ed99d57998b6216bf6" title="Allocate intermediate arrays used by compression.">allocCompressStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f0a7bff9b659cab266bb73538ce6521"></a><!-- doxytag: member="compress_app.cu::freeBwtStorage" ref="ga2f0a7bff9b659cab266bb73538ce6521" args="(CUDPPBwtPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeBwtStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT.">CUDPPBwtPlan</a> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT.">CUDPPBwtPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga6e3305c8f69237c1ba7c859e4c1c8532" title="Allocate intermediate arrays used by BWT.">allocBwtStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa0d04a5e136c191db6d4089006ebeec"></a><!-- doxytag: member="compress_app.cu::freeMtfStorage" ref="gaaa0d04a5e136c191db6d4089006ebeec" args="(CUDPPMtfPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeMtfStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF.">CUDPPMtfPlan</a> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF.">CUDPPMtfPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gaebe506539a6a0c0211ec5b5704a825b0" title="Allocate intermediate arrays used by MTF.">allocMtfStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad14e0a21423bd754bd31d2cedf0cd6c3"></a><!-- doxytag: member="compress_app.cu::cudppCompressDispatch" ref="gad14e0a21423bd754bd31d2cedf0cd6c3" args="(void *d_uncompressed, void *d_bwtIndex, void *d_histSize, void *d_hist, void *d_encodeOffset, void *d_compressedSize, void *d_compressed, size_t numElements, const CUDPPCompressPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppCompressDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_uncompressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_histSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_encodeOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_compressedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPCompressPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform parallel compression on an array with the specified configuration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uncompressed</td><td>Uncompressed data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>BWT Index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histSize</td><td>Histogram size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_hist</td><td>Histogram </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_encodeOffset</td><td>Encoded offset table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressedSize</td><td>Size of compressed data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_compressed</td><td>Compressed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPPCompressPlan object containing compress options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e68297787efbb92efe2c1fb1cb6def9"></a><!-- doxytag: member="compress_app.cu::cudppBwtDispatch" ref="ga3e68297787efbb92efe2c1fb1cb6def9" args="(void *d_bwtIn, void *d_bwtOut, void *d_bwtIndex, size_t numElements, const CUDPPBwtPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppBwtDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_bwtIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_bwtOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_bwtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_bwt_plan.html">CUDPPBwtPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform the Burrows-Wheeler transform. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_bwtIn</td><td>Input data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtOut</td><td>Transformed data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_bwtIndex</td><td>BWT Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_bwt_plan.html" title="Plan class for BWT.">CUDPPBwtPlan</a> object containing compress options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacb94a70fa336d25ddef1ce3833b53258"></a><!-- doxytag: member="compress_app.cu::cudppMtfDispatch" ref="gacb94a70fa336d25ddef1ce3833b53258" args="(void *d_mtfIn, void *d_mtfOut, size_t numElements, const CUDPPMtfPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppMtfDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_mtfIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_mtfOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_mtf_plan.html">CUDPPMtfPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform the Move-to-Front transform. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_mtfIn</td><td>Input data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_mtfOut</td><td>Transformed data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_mtf_plan.html" title="Plan class for MTF.">CUDPPMtfPlan</a> object containing compress options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0429e4ce1e5ab67980778fdcfc58fb63"></a><!-- doxytag: member="listrank_app.cu::listRank" ref="ga0429e4ce1e5ab67980778fdcfc58fb63" args="(T *d_ranked_values, T *d_unranked_values, int *d_next_indices, size_t head, size_t numElements, const CUDPPListRankPlan *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void listRank </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>d_next_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Launch list ranking. </p>
<p>Given two inputs arrays, <em>d_unranked_values</em> and <em>d_next_indices</em>, <a class="el" href="group__cudpp__app.html#ga0429e4ce1e5ab67980778fdcfc58fb63" title="Launch list ranking.">listRank()</a> outputs a ranked version of the unranked values by traversing the next indices. The head index is <em>head</em>. Called by <a class="el" href="group__cudpp__app.html#gaf384cd261f362eef6a000dc5b15aa53e" title="Dispatch function to perform parallel list ranking on a linked-list with the specified configuration...">cudppListRankDispatch()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_next_indices</td><td>Next indices array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head pointer index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of nodes values to rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank.">CUDPPListRankPlan</a> object containing list ranking options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga355d6255be4206b598445d017489fbab"></a><!-- doxytag: member="listrank_app.cu::allocListRankStorage" ref="ga355d6255be4206b598445d017489fbab" args="(CUDPPListRankPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocListRankStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by ListRank. </p>
<p>CUDPPListRank needs temporary device arrays to store next indices so that it does not overwrite the original array.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank.">CUDPPListRankPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbe7bfb2886d9a37ec07836e385635d5"></a><!-- doxytag: member="listrank_app.cu::freeListRankStorage" ref="gacbe7bfb2886d9a37ec07836e385635d5" args="(CUDPPListRankPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeListRankStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block arrays in a <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank.">CUDPPListRankPlan</a> object. </p>
<p>Deallocates the output indices array allocated by <a class="el" href="group__cudpp__app.html#ga355d6255be4206b598445d017489fbab" title="Allocate intermediate arrays used by ListRank.">allocListRankStorage()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank.">CUDPPListRankPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga355d6255be4206b598445d017489fbab" title="Allocate intermediate arrays used by ListRank.">allocListRankStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf384cd261f362eef6a000dc5b15aa53e"></a><!-- doxytag: member="listrank_app.cu::cudppListRankDispatch" ref="gaf384cd261f362eef6a000dc5b15aa53e" args="(void *d_ranked_values, void *d_unranked_values, void *d_next_indices, size_t head, size_t numElements, const CUDPPListRankPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppListRankDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_ranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_unranked_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_next_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_list_rank_plan.html">CUDPPListRankPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform parallel list ranking on a linked-list with the specified configuration. </p>
<p>A wrapper on top of listRank which calls <a class="el" href="group__cudpp__app.html#ga0429e4ce1e5ab67980778fdcfc58fb63" title="Launch list ranking.">listRank()</a> for the data type specified in <em>config</em>. This is the app-level interface to list ranking used by <a class="el" href="group__public_interface.html#ga4c5c71be3d243cc0c849d058827eb0e4" title="Performs list ranking of linked list node values.">cudppListRank()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_ranked_values</td><td>Ranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_unranked_values</td><td>Unranked values array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_next_indices</td><td>Next indices array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head</td><td>Head pointer index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of nodes values to rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_list_rank_plan.html" title="Plan class for ListRank.">CUDPPListRankPlan</a> object containing list ranking options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga79f316efe7af5ccb04524701458ce9d8"></a><!-- doxytag: member="mergesort_app.cu::runMergeSort" ref="ga79f316efe7af5ccb04524701458ce9d8" args="(T *pkeys, unsigned int *pvals, size_t numElements, const CUDPPMergeSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void runMergeSort </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs merge sor utilzing three stages. (1) Blocksort, (2) simple merge and (3) multi merge. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkeys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvals</td><td>Associated values to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergesort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1ad99cc80465972cf1fb732b81ab8e6"></a><!-- doxytag: member="mergesort_app.cu::allocMergeSortStorage" ref="gad1ad99cc80465972cf1fb732b81ab8e6" args="(CUDPPMergeSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocMergeSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html" title="Plan class for mergesort algorithm.">CUDPPMergeSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga290ef022e420d9721f8cb15d1475c074"></a><!-- doxytag: member="mergesort_app.cu::freeMergeSortStorage" ref="ga290ef022e420d9721f8cb15d1475c074" args="(CUDPPMergeSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeMergeSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates intermediate memory from allocRadixSortStorage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html" title="Plan class for mergesort algorithm.">CUDPPMergeSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1cefde64490a053ec2453c0a7897840e"></a><!-- doxytag: member="mergesort_app.cu::cudppMergeSortDispatch" ref="ga1cefde64490a053ec2453c0a7897840e" args="(void *keys, void *values, size_t numElements, const CUDPPMergeSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppMergeSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_merge_sort_plan.html">CUDPPMergeSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls mergeSort...() with appropriate template parameters and arguments as specified by the plan. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergeSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6043ddac717a99c471bb3dc0fc3c0de"></a><!-- doxytag: member="radixsort_app.cu::allocRadixSortStorage" ref="gaa6043ddac717a99c471bb3dc0fc3c0de" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html" title="Plan class for radixsort algorithm.">CUDPPRadixSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b103658becc8dbb8c5ca1026ff61598"></a><!-- doxytag: member="radixsort_app.cu::freeRadixSortStorage" ref="ga5b103658becc8dbb8c5ca1026ff61598" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates intermediate memory from allocRadixSortStorage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html" title="Plan class for radixsort algorithm.">CUDPPRadixSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75c1c0e157a23d4747fc2ae94570aab0"></a><!-- doxytag: member="radixsort_app.cu::cudppRadixSortDispatch" ref="ga75c1c0e157a23d4747fc2ae94570aab0" args="(void *keys, void *values, size_t numElements, const CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppRadixSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls radixSort...() with appropriate template parameters and arguments as specified by the plan. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab8062495149d43064e1f03b4a8f15f9"></a><!-- doxytag: member="scan_app.cu::scanArrayRecursive" ref="gaab8062495149d43064e1f03b4a8f15f9" args="(T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scanArrayRecursive </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>rowPitches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform recursive scan on arbitrary size arrays. </p>
<p>This is the CPU-side workhorse function of the scan engine. This function invokes the CUDA kernels which perform the scan on individual blocks.</p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scanArrayRecursive first invokes a kernel to scan all blocks of that level, and if the level has more than one block, it calls itself recursively. On returning from each recursive level, the total sum of each block from the level below is added to all elements of the corresponding block in this level. See "Parallel Prefix Sum (Scan) in CUDA" for more information (see <a class="el" href="index.html#references">References</a> ).</p>
<p>Template parameter <em>T</em> is the datatype; <em>isBackward</em> specifies backward or forward scan; <em>isExclusive</em> specifies exclusive or inclusive scan, and <em>op</em> specifies the binary associative operator to be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array for the scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of arrays of per-block sums (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitches</td><td>Array of row pitches (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The current recursive level of the scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga344e15dee4b3b2351c40bd9cc732bed6"></a><!-- doxytag: member="scan_app.cu::allocScanStorage" ref="ga344e15dee4b3b2351c40bd9cc732bed6" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by scan. </p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scan, we need an array in which to store the total sums of all blocks in that level. This function computes the amount of storage needed and allocates it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga399f5095b183ad026687fd227802ba5c"></a><!-- doxytag: member="scan_app.cu::freeScanStorage" ref="ga399f5095b183ad026687fd227802ba5c" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object. </p>
<p>These arrays must have been allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>, which is called by the constructor of cudppScanPlan().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49485cb95e21695293a9c35f8355336d"></a><!-- doxytag: member="scan_app.cu::cudppScanDispatch" ref="ga49485cb95e21695293a9c35f8355336d" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppScanDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a scan (prefix sum) on an array with the specified configuration. </p>
<p>This is the dispatch routine which calls <a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9" title="Perform recursive scan on arbitrary size arrays.">scanArrayRecursive()</a> with appropriate template parameters and arguments to achieve the scan as specified in <em>plan</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array of scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows to scan in parallel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing scan options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9efaeeadb705b5709cd2ff27bfc0bab3"></a><!-- doxytag: member="stringsort_app.cu::runStringSort" ref="ga9efaeeadb705b5709cd2ff27bfc0bab3" args="(unsigned int *pkeys, unsigned int *pvals, unsigned int *stringVals, size_t numElements, size_t stringArrayLength, const CUDPPStringSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void runStringSort </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringArrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs merge sor utilzing three stages. (1) Blocksort, (2) simple merge and (3) multi merge on a set of strings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkeys</td><td>Keys (first four characters of string) to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvals</td><td>Addresses of string locations for tie-breaks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringVals</td><td>global string value array (four characters stuffed into a uint) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringArrayLength</td><td>The size of our string array in uints (4 chars per uint) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergesort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe53de69a1cdb089b31247af9d0211a2"></a><!-- doxytag: member="stringsort_app.cu::allocStringSortStorage" ref="gabe53de69a1cdb089b31247af9d0211a2" args="(CUDPPStringSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocStringSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_string_sort_plan.html" title="Plan class for stringsort algorithm.">CUDPPStringSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9270888514859ed9d40a3fc310521cbd"></a><!-- doxytag: member="stringsort_app.cu::freeStringSortStorage" ref="ga9270888514859ed9d40a3fc310521cbd" args="(CUDPPStringSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeStringSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates intermediate memory from allocStringSortStorage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPStringSortPlan object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga607a4608ed36a84e4d35c9c75aa6297a"></a><!-- doxytag: member="stringsort_app.cu::cudppStringSortDispatch" ref="ga607a4608ed36a84e4d35c9c75aa6297a" args="(void *keys, void *values, void *stringVals, size_t numElements, size_t stringArrayLength, const CUDPPStringSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppStringSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stringVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringArrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_string_sort_plan.html">CUDPPStringSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls stringSort...() with appropriate template parameters and arguments as specified by the plan. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys (first four chars of string) to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Address of string values in array of null terminated strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringVals</td><td>Global string array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringArrayLength</td><td>The size of our string array in uints (4 chars per uint) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for mergeSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98079b338b2af21016a5cba9e00a0eb6"></a><!-- doxytag: member="tridiagonal_app.cu::crpcr" ref="ga98079b338b2af21016a5cba9e00a0eb6" args="(T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int numSystems)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void crpcr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>systemSizeOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numSystems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hybrid CR-PCR solver (CRPCR) </p>
<p>This is a wrapper function for the GPU CR-PCR kernel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSizeOriginal</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0509ed92fe9640a9d7ea1ce9cfa639d3"></a><!-- doxytag: member="tridiagonal_app.cu::cudppTridiagonalDispatch" ref="ga0509ed92fe9640a9d7ea1ce9cfa639d3" args="(void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems, const CUDPPTridiagonalPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppTridiagonalDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>systemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSystems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html">CUDPPTridiagonalPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatches the tridiagonal function based on the plan. </p>
<p>This is the dispatch call for the tridiagonal solver in either float or double datatype.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSize</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>pointer to <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html" title="Plan class for tridiagonal solver.">CUDPPTridiagonalPlan</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Mar 8 2013 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
